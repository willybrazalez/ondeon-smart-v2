import { playlistsApi, songsApi } from '../lib/api.js';
import { supabase } from '../lib/supabase.js';
import audioPlayer from './audioPlayerService.js';

/**
 * AutoDJ Service - Sistema completo de reproducci√≥n autom√°tica para Onde√≥n
 * 
 * Funcionalidades principales:
 * - Maneja 2 tipos de playlist: rotaci√≥n, intervalo
 * - Sistema de prioridades: intervalos disparados > rotaci√≥n
 * - Selecci√≥n ponderada por peso para rotaciones
 * - Contador global para intervalos
 * - Manejo de franjas horarias
 * - Retorno autom√°tico despu√©s de interrupciones
 */
class AutoDjService {
  constructor() {
    // Estado del canal
    this.currentChannel = null;
    this.isActive = false;
    
    // Playlists cargadas por tipo
    this.rotationPlaylists = [];
    this.intervalPlaylists = [];
    this.scheduledPlaylists = [];
    
    // Estado de reproducci√≥n actual
    this.currentPlaylist = null;
    this.currentSong = null;
    this.currentSongIndex = 0;
    this.playQueue = [];
    
    // Contadores
    this.globalRotationCounter = 0; // Deprecated: mantenido para compatibilidad de logs

    // Contadores por playlist de intervalo y cola de ejecuci√≥n
    this.intervalCounters = new Map();
    this.pendingIntervalQueue = [];
    
    // Estado de interrupciones
    this.isInInterrupt = false;
    this.interruptType = null; // 'interval' | 'scheduled'
    this.previousRotationState = null;
    
    // üîß NUEVO: Cache para evitar logs repetitivos
    this.timeFrameCache = {};
    
    // üîß NUEVO: Sistema de debouncing para evitar cambios excesivos de canci√≥n
    this.lastSongChangeTime = 0;
    this.minSongChangeInterval = 5000; // M√≠nimo 5 segundos entre cambios
    
    // üîß NUEVO: Flag para evitar ejecuci√≥n m√∫ltiple de playlists agendadas
    this.executedScheduledPlaylists = new Set(); // Set de playlists ya ejecutadas hoy
    
    // Timers para verificaciones autom√°ticas
    this.schedulingTimer = null;
    this.clockTimer = null;
    
    // Protecci√≥n contra bucles infinitos
    this.lastErrorTime = 0;
    this.errorCount = 0;
    this.maxErrors = 5;
    this.errorResetTime = 10000; // 10 segundos
    this.isInErrorState = false;
    this.requiresUserInteraction = false;
    
    // üîß SISTEMA H√çBRIDO: Control de precarga inteligente
    this.userHasStartedPlaying = false; // Solo precargar despu√©s de primera interacci√≥n
    this.smartPreloadEnabled = false;   // Activar precarga autom√°tica tras primer play
    
    // Configuraci√≥n
    this.config = {
      schedulingCheckInterval: 300000, // Verificar cada 5 minutos (en lugar de 30 segundos)
      clockCheckInterval: 1000, // Verificar reloj cada segundo
      maxHistorySize: 100
    };

    // Control de precarga
    this.lastPreloadAttempt = 0;
    this.preloadErrorCount = 0;
    
    // üîß NUEVO: Flag de protecci√≥n contra ejecuciones concurrentes
    this.isHandlingSongEnd = false;

    // üîß NUEVO: Sistema de sincronizaci√≥n en tiempo real con Supabase
    this.realtimeSubscriptions = new Map(); // Mapa de suscripciones por tabla
    this.lastSyncTime = Date.now();
    this.syncInterval = 300000; // Sincronizar cada 5 minutos como respaldo (menos agresivo)
    this.syncTimer = null;

    // üîß NUEVO: Sistema para evitar repetici√≥n de canciones
    this.recentlyPlayedSongs = []; // Historial de canciones recientes
    this.maxRecentSongs = 20; // M√°ximo n√∫mero de canciones a recordar
    this.avoidRepetitionPercentage = 0.3; // Evitar repetir el 30% de las canciones m√°s recientes

    // Configurar eventos del reproductor de audio
    this.setupAudioEvents();

    // console.log('üéµ AutoDJ Service (Onde√≥n) inicializado con sistema h√≠brido');
  }

  /**
   * üîß NUEVO: Agregar canci√≥n al historial para evitar repeticiones
   */
  addSongToHistory(song) {
    if (!song) return;
    
    const songId = song?.canciones?.id || song?.id;
    const songTitle = song?.canciones?.titulo || song?.titulo;
    
    if (!songId) return;
    
    // Agregar al inicio del array
    this.recentlyPlayedSongs.unshift({
      id: songId,
      title: songTitle,
      timestamp: Date.now()
    });
    
    // Mantener solo las canciones m√°s recientes
    if (this.recentlyPlayedSongs.length > this.maxRecentSongs) {
      this.recentlyPlayedSongs = this.recentlyPlayedSongs.slice(0, this.maxRecentSongs);
    }
    
    console.log('üìù Canci√≥n agregada al historial:', {
      title: songTitle,
      historySize: this.recentlyPlayedSongs.length
    });
  }

  /**
   * üîß NUEVO: Verificar si una canci√≥n fue reproducida recientemente
   */
  wasSongRecentlyPlayed(song) {
    if (!song || this.recentlyPlayedSongs.length === 0) return false;
    
    const songId = song?.canciones?.id || song?.id;
    if (!songId) return false;
    
    // Calcular cu√°ntas canciones del historial debemos evitar
    const songsToAvoid = Math.floor(this.recentlyPlayedSongs.length * this.avoidRepetitionPercentage);
    const recentSongsToCheck = this.recentlyPlayedSongs.slice(0, songsToAvoid);
    
    return recentSongsToCheck.some(recentSong => recentSong.id === songId);
  }

  /**
   * üîß NUEVO: Filtrar canciones para evitar repeticiones recientes
   */
  filterRecentlyPlayedSongs(songs) {
    if (!Array.isArray(songs) || songs.length === 0) return songs;
    
    const availableSongs = songs.filter(song => !this.wasSongRecentlyPlayed(song));
    
    // Si todas las canciones fueron reproducidas recientemente, permitir cualquiera
    // (esto evita que se quede sin opciones en playlists peque√±as)
    if (availableSongs.length === 0) {
      console.log('‚ö†Ô∏è Todas las canciones fueron reproducidas recientemente, permitiendo repetici√≥n');
      return songs;
    }
    
    console.log('üö´ Canciones filtradas por repetici√≥n:', {
      totalSongs: songs.length,
      availableSongs: availableSongs.length,
      filteredOut: songs.length - availableSongs.length
    });
    
    return availableSongs;
  }

  /**
   * üîß NUEVO: Configurar sincronizaci√≥n en tiempo real con Supabase
   */
  setupRealtimeSync() {
    if (!this.currentChannel) {
      console.log('‚ö†Ô∏è No hay canal activo para sincronizaci√≥n en tiempo real');
      return;
    }

    console.log('üîÑ Configurando sincronizaci√≥n en tiempo real para canal:', this.currentChannel.id);

    // Limpiar suscripciones anteriores
    this.cleanupRealtimeSubscriptions();

    // Suscribirse a cambios en playlists del canal actual
    const playlistSubscription = supabase
      .channel(`playlists-${this.currentChannel.id}`)
      .on(
        'postgres_changes',
        {
          event: '*', // INSERT, UPDATE, DELETE
          schema: 'public',
          table: 'playlists',
          filter: `canal_id=eq.${this.currentChannel.id}`
        },
        (payload) => {
          console.log('üîÑ Cambio detectado en playlists:', payload);
          this.handlePlaylistChange(payload);
        }
      )
      .subscribe();

    // Suscribirse a cambios en canciones del canal actual
    const songsSubscription = supabase
      .channel(`songs-${this.currentChannel.id}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'canciones',
          filter: `canal_id=eq.${this.currentChannel.id}`
        },
        (payload) => {
          console.log('üîÑ Cambio detectado en canciones:', payload);
          this.handleSongChange(payload);
        }
      )
      .subscribe();

    // Guardar referencias a las suscripciones
    this.realtimeSubscriptions.set('playlists', playlistSubscription);
    this.realtimeSubscriptions.set('songs', songsSubscription);

    // Timer de respaldo para sincronizaci√≥n peri√≥dica
    this.syncTimer = setInterval(() => {
      this.forceSync();
    }, this.syncInterval);

    console.log('‚úÖ Sincronizaci√≥n en tiempo real configurada');
  }

  /**
   * üîß NUEVO: Limpiar suscripciones en tiempo real
   */
  cleanupRealtimeSubscriptions() {
    console.log('üßπ Limpiando suscripciones en tiempo real...');
    
    this.realtimeSubscriptions.forEach((subscription, key) => {
      if (subscription) {
        supabase.removeChannel(subscription);
        console.log(`üóëÔ∏è Suscripci√≥n ${key} eliminada`);
      }
    });
    
    this.realtimeSubscriptions.clear();

    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }

  /**
   * üîß NUEVO: Manejar cambios en playlists
   */
  async handlePlaylistChange(payload) {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    
    console.log(`üîÑ Playlist ${eventType}:`, {
      eventType,
      playlistId: newRecord?.id || oldRecord?.id,
      playlistName: newRecord?.nombre || oldRecord?.nombre
    });

    // Aplicar cambios inmediatamente (realtime): recargar y recalcular estado
    // Si estamos en una interrupci√≥n, igualmente actualizamos el estado en memoria
    void this.reloadPlaylists();
  }

  /**
   * üîß NUEVO: Manejar cambios en canciones
   */
  async handleSongChange(payload) {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    
    console.log(`üîÑ Canci√≥n ${eventType}:`, {
      eventType,
      songId: newRecord?.id || oldRecord?.id,
      songTitle: newRecord?.titulo || oldRecord?.titulo
    });

    // Si la canci√≥n actual fue modificada, recargar
    // Solo si no estamos en una interrupci√≥n
    if (this.currentSong && !this.isInInterrupt &&
        (newRecord?.id === this.currentSong.id || oldRecord?.id === this.currentSong.id)) {
      console.log('üîÑ Canci√≥n actual modificada - recargando...');
      setTimeout(async () => {
        await this.reloadPlaylists();
      }, 3000); // 3 segundos para evitar recargas excesivas
    }
  }

  /**
   * üîß NUEVO: Recargar playlists desde la base de datos
   */
  async reloadPlaylists() {
    if (!this.currentChannel) {
      console.log('‚ö†Ô∏è No hay canal activo para recargar playlists');
      return;
    }

    console.log('üîÑ Recargando playlists desde Supabase...');
    
    // üîß CORREGIDO: Limpiar cache de timeframes al recargar
    this.timeFrameCache = {};
    
    try {
      // Recargar playlists del canal
      await this.loadChannelPlaylists();
      
      // Reconstruir contadores y limpiar cola seg√∫n nuevas playlists/horarios
      this.rebuildIntervalCounters();
      // Reconfigurar contadores de intervalos para playlists actuales
      this.rebuildIntervalCounters();
      
      // Actualizar timestamp de √∫ltima sincronizaci√≥n
      this.lastSyncTime = Date.now();
      
      console.log('‚úÖ Playlists recargadas exitosamente');
      
      // Si hay una canci√≥n cargada, verificar si sigue siendo v√°lida
      // Solo validar si no estamos en una interrupci√≥n para evitar conflictos
      if (this.currentSong && !this.isInInterrupt) {
        try {
          const isValid = await this.validateCurrentSong();
          if (!isValid) {
            console.log('‚ö†Ô∏è Canci√≥n actual ya no es v√°lida - seleccionando nueva...');
            await this.selectNextSong();
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error en validaci√≥n de canci√≥n actual (ignorando):', error.message);
          // No forzar selecci√≥n de nueva canci√≥n si hay error en validaci√≥n
        }
      }
      
      // Aplicar efectos inmediatos de franjas horarias activadas/desactivadas
      this.applyImmediateTimeFrameEffects();
    } catch (error) {
      console.error('‚ùå Error al recargar playlists:', error);
    }
  }

  /**
   * üîß NUEVO: Validar si la canci√≥n actual sigue siendo v√°lida
   */
  async validateCurrentSong() {
    if (!this.currentSong || !this.currentPlaylist) {
      return false;
    }

    try {
      // Verificar si la playlist actual sigue activa
      const playlist = this.rotationPlaylists
        .concat(this.intervalPlaylists)
        .find(p => p.id === this.currentPlaylist.id);

      if (!playlist || !playlist.activa) {
        console.log('‚ö†Ô∏è Playlist actual ya no est√° activa');
        return false;
      }

      // Verificar si la canci√≥n sigue en la playlist
      const songs = await songsApi.getPlaylistSongs(this.currentPlaylist.id);
      const songExists = songs.some(song => song.id === this.currentSong.id);
      
      if (!songExists) {
        console.log('‚ö†Ô∏è Canci√≥n actual ya no est√° en la playlist');
        return false;
      }

      return true;
    } catch (error) {
      console.error('‚ùå Error al validar canci√≥n actual:', error);
      // En caso de error, asumir que la canci√≥n es v√°lida para evitar interrupciones
      return true;
    }
  }

  /**
   * üîß NUEVO: Forzar sincronizaci√≥n manual
   */
  async forceSync() {
    console.log('üîÑ Forzando sincronizaci√≥n manual...');
    await this.reloadPlaylists();
  }



  /**
   * Reconstruir contadores de intervalos tras recarga de playlists
   */
  rebuildIntervalCounters() {
    const newMap = new Map();
    for (const p of this.intervalPlaylists) {
      const prev = this.intervalCounters.get(p.id) ?? 0;
      newMap.set(p.id, Math.max(0, prev));
    }
    this.intervalCounters = newMap;
    // Limpiar cola de intervalos no v√°lidos
    this.pendingIntervalQueue = this.pendingIntervalQueue.filter(p => this.intervalCounters.has(p.id));
  }

  /**
   * Incrementar contadores de todas las playlists de intervalo activas (operacionales ahora)
   */
  incrementIntervalCounters() {
    // Incrementar el contador de TODAS las playlists de intervalo activas, est√©n o no en franja.
    // Esto permite reglas como "cada 3 canciones" de forma consistente, incluso si
    // una playlist entra en franja m√°s tarde: disparar√° solo cuando el contador >= repetir_cada.
    for (const p of this.intervalPlaylists) {
      const current = Number(this.intervalCounters.get(p.id) ?? 0);
      this.intervalCounters.set(p.id, current + 1);
    }
  }

  /**
   * Determinar si una playlist est√° activa (activa=true) y dentro de franja local
   */
  isPlaylistOperationalNow(playlist) {
    const isActiveFlag = playlist?.activa === true || playlist?.activa === 1;
    return !!isActiveFlag && this.isInActiveTimeFrame(playlist);
  }

  /**
   * Aplicar efectos inmediatos de cambios de franja horaria/activa
   */
  applyImmediateTimeFrameEffects() {
    // Si la playlist actual dej√≥ de ser operativa, finalizar interrupci√≥n y volver a rotaci√≥n
    if (this.currentPlaylist && !this.isPlaylistOperationalNow(this.currentPlaylist)) {
      console.log('‚è±Ô∏è Playlist actual dej√≥ de estar operativa, retornando a rotaci√≥n');
      this.endInterrupt();
    }
  }

  /**
   * Chequear transiciones de franja horaria cada segundo
   */
  checkTimeFrameTransitions() {
    try {
      // Construir cola si alguna playlist entra en franja y su contador cumple
      const newlyTriggered = [];
      for (const p of this.intervalPlaylists) {
        const was = p.__wasOperational || false;
        const now = this.isPlaylistOperationalNow(p);
        if (!was && now) {
          const count = this.intervalCounters.get(p.id) ?? 0;
          if (p.repetir_unidad === 'canciones' && count >= p.repetir_cada) {
            newlyTriggered.push(p);
            this.intervalCounters.set(p.id, 0);
          }
        }
        p.__wasOperational = now;
      }
      if (newlyTriggered.length > 0) {
        newlyTriggered.sort((a, b) => (a.repetir_cada || 0) - (b.repetir_cada || 0));
        this.pendingIntervalQueue.push(...newlyTriggered);
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Error en checkTimeFrameTransitions:', e);
    }
  }

  /**
   * Configurar eventos del reproductor de audio
   */
  setupAudioEvents() {
    // Limpiar eventos previos
    this.clearAudioEvents();
    
    // Evento principal: cuando termina una canci√≥n
    this.onEndHandler = (song) => {
      console.log('üîö AutoDJ: Evento onEnd recibido para:', song?.canciones?.titulo || song?.titulo);
      // Si termin√≥ una canci√≥n de rotaci√≥n, incrementar contadores por playlist de intervalo
      if (!this.isInInterrupt) {
        this.globalRotationCounter++;
        this.incrementIntervalCounters();
      }
      this.handleSongEnd();
    };
    audioPlayer.on('onEnd', this.onEndHandler);

    // Eventos de estado
    this.onPlayHandler = (song) => {
      console.log('‚ñ∂Ô∏è AutoDJ: Reproducci√≥n iniciada:', song?.canciones?.titulo || song?.titulo);
      if (!this.userHasStartedPlaying) {
        this.userHasStartedPlaying = true;
        this.smartPreloadEnabled = true;
        console.log('üéØ PRIMERA REPRODUCCI√ìN: Activando precarga autom√°tica inteligente');
        setTimeout(() => {
          this.preloadNextSong();
        }, 2000);
      }
    };
    audioPlayer.on('onPlay', this.onPlayHandler);

    this.onPauseHandler = (song) => {
      console.log('‚è∏Ô∏è AutoDJ: Reproducci√≥n pausada:', song?.canciones?.titulo || song?.titulo);
    };
    audioPlayer.on('onPause', this.onPauseHandler);

    this.onRequestPreloadHandler = () => {
      if (!this.smartPreloadEnabled) {
        console.log('üì° Precarga JUST-IN-TIME solicitada (usuario no ha reproducido a√∫n)');
        this.preloadNextSong();
      } else {
        console.log('üì° Precarga JUST-IN-TIME ignorada (precarga autom√°tica ya activa)');
      }
    };
    audioPlayer.on('onRequestPreload', this.onRequestPreloadHandler);

    this.onErrorHandler = (errorData) => {
      const now = Date.now();
      const errorMessage = errorData.message || errorData.error?.message || 'Error desconocido';
      const errorCode = errorData.errorCode;
      const songTitle = errorData.songTitle || 'Canci√≥n desconocida';
      
      console.error('‚ùå AutoDJ: Error en reproductor:', {
        message: errorMessage,
        code: errorCode,
        song: songTitle,
        error: errorData
      });
      
      if (errorMessage.includes('NotAllowedError') || 
          errorMessage.includes('user didn\'t interact') ||
          errorMessage.includes('autoplay')) {
        console.warn('üö´ Error de autoplay detectado - se requiere interacci√≥n del usuario');
        this.requiresUserInteraction = true;
        this.isInErrorState = true;
        this.stopErrorLoop();
        return;
      }
      if (errorMessage.includes('crossfade desactivado') || 
          errorMessage.includes('Precarga saltada')) {
        console.log('‚ÑπÔ∏è Error de precarga ignorado - crossfade desactivado (comportamiento normal)');
        return;
      }
      
      // üîß NUEVO: Manejo espec√≠fico para errores de archivos corruptos
      if (errorCode === 4 || errorMessage.includes('DEMUXER_ERROR') || 
          errorMessage.includes('SRC_NOT_SUPPORTED') || 
          errorMessage.includes('Formato no soportado')) {
        console.warn('‚ö†Ô∏è Archivo de audio corrupto o no soportado:', songTitle);
        console.warn('üîÑ Intentando siguiente canci√≥n autom√°ticamente...');
        
        // Limpiar canci√≥n actual que fall√≥
        this.currentSong = null;
        
        if (!this.isInErrorState && !this.requiresUserInteraction) {
          setTimeout(() => {
            this.handleSongEnd();
          }, 1000); // Menos tiempo para archivos corruptos
        }
        return;
      }
      
      if (now - this.lastErrorTime < 1000) {
        this.errorCount++;
      } else {
        this.errorCount = 1;
      }
      this.lastErrorTime = now;
      if (this.errorCount >= this.maxErrors) {
        console.error('üö® Demasiados errores consecutivos, pausando AutoDJ');
        this.isInErrorState = true;
        this.stopErrorLoop();
        setTimeout(() => {
          this.resetErrorState();
        }, this.errorResetTime);
        return;
      }
      if (!this.isInErrorState && !this.requiresUserInteraction) {
        setTimeout(() => {
          this.handleSongEnd();
        }, 2000);
      }
    };
    audioPlayer.on('onError', this.onErrorHandler);

    // üîß NUEVO: Eventos de interrupci√≥n agendada
    this.onInterruptionStartHandler = (data) => {
      console.log('üé≠ AutoDJ: Inicio de interrupci√≥n agendada:', {
        currentSong: data.currentSong?.canciones?.titulo || data.currentSong?.titulo,
        interruptionSong: data.interruptionSong?.canciones?.titulo || data.interruptionSong?.titulo
      });
    };
    audioPlayer.on('onInterruptionStart', this.onInterruptionStartHandler);
  }

  /**
   * Limpiar eventos del reproductor de audio
   */
  clearAudioEvents() {
    if (this.onEndHandler) {
      audioPlayer.off('onEnd', this.onEndHandler);
      audioPlayer.off('onPlay', this.onPlayHandler);
      audioPlayer.off('onPause', this.onPauseHandler);
      audioPlayer.off('onError', this.onErrorHandler);
      audioPlayer.off('onRequestPreload', this.onRequestPreloadHandler);
      audioPlayer.off('onInterruptionStart', this.onInterruptionStartHandler);
      audioPlayer.off('onInterruptionEnd', this.onInterruptionEndHandler);
    }
  }

  /**
   * Limpieza suave para cambios de canal (deteniendo reproducci√≥n actual)
   */
  async cleanupForChannelChange() {
    console.log('üîÑ Limpieza suave para cambio de canal...');
    
    // üîß CR√çTICO: Detener reproducci√≥n actual antes de limpiar
    if (audioPlayer && audioPlayer.isPlaying) {
      console.log('‚èπÔ∏è Deteniendo reproducci√≥n actual antes del cambio de canal');
      try {
        await audioPlayer.stop();
      } catch (error) {
        console.warn('‚ö†Ô∏è Error deteniendo audio durante cambio de canal:', error);
      }
    }
    
    // Limpiar timers y suscripciones
    this.stopTimers();
    
    try {
      this.cleanupRealtimeSubscriptions();
    } catch (error) {
      console.warn('‚ö†Ô∏è Error limpiando suscripciones realtime:', error);
    }
    
    // Resetear estado de playlists pero mantener canal activo
    this.rotationPlaylists = [];
    this.intervalPlaylists = [];
    this.scheduledPlaylists = [];
    this.currentPlaylist = null;
    this.currentSong = null; // üîß CORREGIDO: Limpiar canci√≥n actual
    this.playQueue = [];
    
    // Resetear contadores pero mantener estado activo
    this.globalRotationCounter = 0;
    this.intervalCounters.clear();
    this.pendingIntervalQueue = [];
    
    // Limpiar estado de interrupciones
    this.isInInterrupt = false;
    this.interruptType = null;
    this.previousRotationState = null;
    
    // Resetear flag de protecci√≥n pero mantener activo
    this.isHandlingSongEnd = false;
    
    // üîß NUEVO: Resetear estado de reproducci√≥n
    this.isPlaying = false;
    this.isPaused = false;
    
    // CR√çTICO: Mantener isActive = true para indicar que seguimos funcionando
    console.log('‚úÖ Limpieza suave completada - manteniendo estado activo');
  }

  /**
   * Inicializar AutoDJ para un canal espec√≠fico
   */
  async initializeChannel(channel) {
    try {
      console.log('üéõÔ∏è Inicializando AutoDJ para canal:', channel?.nombre || channel?.name || channel?.id);
      
      
      // Evitar reinicializar si ya estamos activos en el mismo canal
      if (this.isActive && this.currentChannel?.id && channel?.id && this.currentChannel.id === channel.id) {
        console.log('‚è≠Ô∏è AutoDJ ya inicializado para este canal, ignorando reinicializaci√≥n');
        return true;
      }
      
      // üî• MEJORADO: Detecci√≥n de cambio de canal vs inicializaci√≥n completa
      const isChannelChange = this.isActive && this.currentChannel?.id && channel?.id && this.currentChannel.id !== channel.id;
      const wasPlaying = audioPlayer.getState().isPlaying;
      
      if (isChannelChange) {
        console.log('üîÑ Cambiando canal de', this.currentChannel.nombre || this.currentChannel.name, 'a', channel.nombre || channel.name);
        console.log('üéµ Estado de reproducci√≥n:', wasPlaying ? 'REPRODUCIENDO' : 'PARADO');
        
        // Para cambios de canal, solo limpiar estado sin detener audio completamente
        await this.cleanupForChannelChange();
      } else {
        console.log('üßπ Inicializaci√≥n completa - limpiando estado anterior...');
        this.stop(); // Limpieza completa solo para inicializaciones nuevas
      }
      
      // PASO 2: Peque√±a pausa para asegurar limpieza completa
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // PASO 3: Configurar nuevo canal
      this.currentChannel = channel;
      
      // PASO 3.1: CR√çTICO - Establecer canal en audioPlayerService para verificaciones
      audioPlayer.setCurrentChannel(channel.id);
      
      // PASO 3.2: EMERGENCIA - Limpiar cualquier canci√≥n precargada incorrecta
      const cleaned = audioPlayer.forceCleanIncorrectPreloadedSong();
      if (cleaned) {
        console.log('üßπ Canci√≥n precargada incorrecta eliminada durante inicializaci√≥n');
      }
      
      // PASO 4: Resetear estado para nuevo canal
      this.resetState();
      
      // PASO 5: Cargar todas las playlists del canal
      console.log('üìÇ Cargando playlists del nuevo canal...');
      await this.loadChannelPlaylists();
      
      // PASO 6: üîß NUEVO: Configurar sincronizaci√≥n en tiempo real
      console.log('üîÑ Configurando sincronizaci√≥n en tiempo real...');
      this.setupRealtimeSync();
      
      // PASO 7: Iniciar reproducci√≥n autom√°tica
      console.log('üöÄ Iniciando sistema AutoDJ...');
      await this.start();
      
      // PASO 8: Si era un cambio de canal y estaba reproduciendo, continuar autom√°ticamente
      if (isChannelChange && wasPlaying) {
        console.log('‚ñ∂Ô∏è Era cambio de canal y estaba reproduciendo - continuando autom√°ticamente...');
        setTimeout(async () => {
          try {
            // Forzar reproducci√≥n directamente en el audioPlayer
            await audioPlayer.play();
            console.log('‚úÖ Reproducci√≥n continuada exitosamente tras cambio de canal');
          } catch (error) {
            console.error('‚ùå Error continuando reproducci√≥n tras cambio de canal:', error);
            // Fallback: intentar con togglePlayPause
            try {
              await this.togglePlayPause();
              console.log('‚úÖ Reproducci√≥n iniciada con toggle como fallback');
            } catch (fallbackError) {
              console.error('‚ùå Error en fallback toggle:', fallbackError);
            }
          }
        }, 800); // Mayor delay para asegurar que todo est√© completamente listo
      }
      
      // PASO 9: Iniciar timers de verificaci√≥n
      this.startTimers();
      
      console.log('‚úÖ AutoDJ inicializado exitosamente para:', channel?.nombre || channel?.name);
      return true;
    } catch (error) {
      console.error('‚ùå Error inicializando AutoDJ:', error);
      console.error('üîç Detalles del error:', {
        channelId: channel?.id,
        channelName: channel?.nombre || channel?.name,
        errorMessage: error.message,
        errorStack: error.stack
      });
      
      // En caso de error, asegurar limpieza
      try {
        this.stop();
      } catch (cleanupError) {
        console.error('‚ùå Error en limpieza tras fallo:', cleanupError);
      }
      
      return false;
    }
  }

  /**
   * Resetear estado interno
   */
  resetState() {
    console.log('üßπ Reseteando estado interno del AutoDJ...');
    
    // Resetear listas de playlists
    this.rotationPlaylists = [];
    this.intervalPlaylists = [];
    this.scheduledPlaylists = [];
    
    // Resetear estado de reproducci√≥n
    this.currentPlaylist = null;
    this.currentSong = null;
    this.currentSongIndex = 0;
    this.playQueue = [];
    
    // Resetear contadores
    this.globalRotationCounter = 0;
    
    // Resetear interrupciones
    this.isInInterrupt = false;
    this.interruptType = null;
    this.previousRotationState = null;
    
    // üîß SISTEMA H√çBRIDO: Resetear estado de precarga inteligente
    this.userHasStartedPlaying = false;
    this.smartPreloadEnabled = false;
    console.log('üîÑ Sistema h√≠brido reseteado - volver√° a just-in-time hasta primera reproducci√≥n');
    
    // Resetear control de precarga
    this.lastPreloadAttempt = 0;
    this.preloadErrorCount = 0;
    
    // üîß NUEVO: Resetear flag de protecci√≥n contra ejecuciones concurrentes
    this.isHandlingSongEnd = false;
    
    // Resetear flag de playlists agendadas ejecutadas
    this.executedScheduledPlaylists.clear();
    
    // Detener timers
    this.stopTimers();
    
    console.log('‚úÖ Estado interno reseteado completamente');
  }

  /**
   * Detener completamente el AutoDJ y limpiar todo
   */
  stop() {
    try {
      console.log('‚èπÔ∏è Deteniendo AutoDJ completamente...');
      
      // Marcar como inactivo
      this.isActive = false;
      
      // Detener timers
      this.stopTimers();
      
      // Limpiar estado de error
      this.resetErrorState();
      
      // Detener y limpiar audioPlayer
      this.cleanupAudioPlayer();
      
      // Limpiar eventos del audioPlayer
      this.clearAudioEvents();
      
      // üîß NUEVO: Limpiar suscripciones en tiempo real
      this.cleanupRealtimeSubscriptions();
      
      // Resetear estado interno (sin llamar a stop nuevamente)
      this.rotationPlaylists = [];
      this.intervalPlaylists = [];
      this.scheduledPlaylists = [];
      this.currentPlaylist = null;
      this.currentSong = null;
      this.currentSongIndex = 0;
      this.playQueue = [];
      this.globalRotationCounter = 0;
      this.isInInterrupt = false;
      this.interruptType = null;
      this.previousRotationState = null;
      
      // Resetear control de precarga
      this.lastPreloadAttempt = 0;
      this.preloadErrorCount = 0;
      
      // üîß NUEVO: Resetear flag de protecci√≥n
      this.isHandlingSongEnd = false;
      
      // Resetear flag de playlists agendadas ejecutadas
      this.executedScheduledPlaylists.clear();
      
      console.log('‚úÖ AutoDJ detenido completamente');
    } catch (error) {
      console.error('‚ùå Error deteniendo AutoDJ:', error);
    }
  }

  /**
   * Limpiar completamente el audioPlayer
   */
  cleanupAudioPlayer() {
    try {
      console.log('üßπ Limpiando AudioPlayer...');
      
      // Mostrar estado antes de limpiar
      const audioState = audioPlayer.getState();
      console.log('üìä Estado AudioPlayer antes de limpiar:', {
        isPlaying: audioState.isPlaying,
        currentSong: audioState.currentSong?.canciones?.titulo || audioState.currentSong?.titulo || 'Ninguna',
        nextSong: audioState.nextSong?.canciones?.titulo || audioState.nextSong?.titulo || 'Ninguna',
        nextSongLoaded: audioState.nextSongLoaded,
        isCrossfading: audioState.isCrossfading
      });
      
      // Usar el nuevo m√©todo reset del audioPlayerService
      audioPlayer.reset();
      
      // Verificar que se limpi√≥ correctamente
      const audioStateAfter = audioPlayer.getState();
      console.log('üìä Estado AudioPlayer despu√©s de limpiar:', {
        isPlaying: audioStateAfter.isPlaying,
        currentSong: audioStateAfter.currentSong,
        nextSong: audioStateAfter.nextSong,
        nextSongLoaded: audioStateAfter.nextSongLoaded,
        isCrossfading: audioStateAfter.isCrossfading
      });
      
      // Verificaci√≥n cr√≠tica
      if (audioStateAfter.nextSong || audioStateAfter.nextSongLoaded) {
        console.error('‚ùå CR√çTICO: AudioPlayer no se limpi√≥ completamente!', {
          nextSong: audioStateAfter.nextSong,
          nextSongLoaded: audioStateAfter.nextSongLoaded
        });
      } else {
        console.log('‚úÖ AudioPlayer limpiado completamente - sin canciones residuales');
      }
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Error limpiando AudioPlayer:', error);
    }
  }

  /**
   * Cargar todas las playlists del canal clasificadas por tipo
   */
  async loadChannelPlaylists() {
    try {
      console.log('üìÇ Cargando playlists del canal...');
      
      const allPlaylists = await playlistsApi.getChannelPlaylists(this.currentChannel.id);
      
      console.log('üìÇ Playlists del canal:', allPlaylists?.length || 0);
      console.log('üîç DEBUG - Todas las playlists cargadas:', allPlaylists?.map(p => ({
        nombre: p.nombre,
        tipo: p.tipo,
        activa: p.activa,
        canal_id: p.canal_id,
        activa_desde: p.activa_desde,
        activa_hasta: p.activa_hasta
      })));
      
      // Filtrar usando la estructura real de la base de datos
      // La API ya filtra por 'activa = true', pero por si acaso verificamos tambi√©n
      this.rotationPlaylists = allPlaylists.filter(p => {
        const isCorrectType = (p.tipo === 'rotacion' || p.tipo === 'general');
        const isActive = (p.activa === true || p.activa === 1);
        const belongsToChannel = !p.canal_id || p.canal_id === this.currentChannel.id;
        
        if (!belongsToChannel) {
          console.warn('üö´ Playlist de rotaci√≥n filtrada (canal incorrecto):', {
            nombre: p.nombre,
            playlistCanalId: p.canal_id,
            currentChannelId: this.currentChannel.id
          });
        }
        
        return isCorrectType && isActive && belongsToChannel;
      });
      
      this.intervalPlaylists = allPlaylists.filter(p => {
        const isCorrectType = p.tipo === 'intervalo';
        const isActive = (p.activa === true || p.activa === 1);
        const belongsToChannel = !p.canal_id || p.canal_id === this.currentChannel.id;
        
        if (!belongsToChannel) {
          console.warn('üö´ Playlist de intervalo filtrada (canal incorrecto):', {
            nombre: p.nombre,
            playlistCanalId: p.canal_id,
            currentChannelId: this.currentChannel.id
          });
        }
        
        if (!isActive) {
          console.warn('üö´ Playlist de intervalo filtrada (inactiva):', {
            nombre: p.nombre,
            activa: p.activa
          });
        }
        
        console.log(`üìã Playlist de intervalo "${p.nombre}": tipo=${isCorrectType}, activa=${isActive}, canal=${belongsToChannel} -> ${isCorrectType && isActive && belongsToChannel ? 'INCLUIDA' : 'FILTRADA'}`);
        
        return isCorrectType && isActive && belongsToChannel;
      });
      
      // Eliminar soporte de playlists agendadas
      this.scheduledPlaylists = [];
      
      console.log('üìä Playlists clasificadas (solo rotaci√≥n/intervalo):', {
        rotacion: this.rotationPlaylists.length,
        intervalo: this.intervalPlaylists.length
      });
      
      // Si a√∫n no hay playlists de rotaci√≥n, usar todas las disponibles como fallback
              if (this.rotationPlaylists.length === 0) {
        console.error('‚ùå No hay playlists de rotaci√≥n v√°lidas en este canal');
        throw new Error(`No hay playlists de rotaci√≥n v√°lidas en el canal "${this.currentChannel?.nombre || this.currentChannel?.id}". Verificar configuraci√≥n.`);
      }
      
      // Validar que hay al menos una playlist
      if (this.rotationPlaylists.length === 0) {
        console.error('‚ùå No hay playlists disponibles en el canal');
        throw new Error('No hay playlists disponibles en el canal. Verificar configuraci√≥n de la base de datos.');
      } else {
        console.log('‚úÖ Playlists de rotaci√≥n encontradas:', this.rotationPlaylists.map(p => p.nombre));
      }
      
    } catch (error) {
      console.error('‚ùå Error cargando playlists:', error);
      console.log('üîç DEBUG - Detalles del error:', {
        message: error.message,
        stack: error.stack,
        channelId: this.currentChannel?.id,
        channelName: this.currentChannel?.nombre || this.currentChannel?.name
      });
      
      // Verificar si es un error de la API
      if (error.message.includes('fetch') || error.message.includes('network') || error.message.includes('API')) {
        console.warn('‚ö†Ô∏è Parece ser un error de conexi√≥n con la API');
        throw new Error('Error de conexi√≥n con el servidor. Verificar conectividad.');
      }
      
      throw error;
    }
  }

  /**
   * Iniciar reproducci√≥n autom√°tica
   */
  async start() {
    try {
      console.log('üöÄ Iniciando reproducci√≥n autom√°tica...');
      this.isActive = true;
      
      // Resetear estado de error
      this.resetErrorState();
      
      // Seleccionar primera canci√≥n
      const firstSong = await this.selectNextSong();
      if (firstSong) {
        // Cargar canci√≥n pero no reproducir autom√°ticamente (por pol√≠ticas de autoplay)
        await this.loadSongOnly(firstSong);
        console.log('üìº Canci√≥n cargada. Haz clic en play para iniciar la reproducci√≥n.');
      } else {
        throw new Error('No se pudo seleccionar primera canci√≥n');
      }
      
    } catch (error) {
      console.error('‚ùå Error iniciando reproducci√≥n:', error);
      
      // Si es error de autoplay, no relanzar error
      if (error.message && error.message.includes('NotAllowedError')) {
        console.warn('üö´ Reproducci√≥n autom√°tica bloqueada por el navegador');
        this.requiresUserInteraction = true;
        return; // No relanzar el error
      }
      
      throw error;
    }
  }

  /**
   * Detener AutoDJ
   */
  stop() {
    console.log('‚èπÔ∏è Deteniendo AutoDJ...');
    this.isActive = false;
    this.stopTimers();
    audioPlayer.stop();
  }

  /**
   * Pausar/reanudar reproducci√≥n
   */
  async togglePlayPause() {
    try {
      // Si es la primera interacci√≥n del usuario, permitir reproducci√≥n
      if (this.requiresUserInteraction) {
        this.allowPlaybackAfterInteraction();
      }

      const audioState = audioPlayer.getState();
      if (audioState.isPlaying) {
        audioPlayer.pause();
      } else {
        await audioPlayer.play();
        console.log('‚ñ∂Ô∏è Reproducci√≥n iniciada por interacci√≥n del usuario');
      }
    } catch (error) {
      console.error('‚ùå Error en togglePlayPause:', error);
      
      // Si es error de autoplay a√∫n, mantener el estado
      if (error.message && error.message.includes('NotAllowedError')) {
        console.warn('üö´ A√∫n se requiere m√°s interacci√≥n del usuario');
        this.requiresUserInteraction = true;
      }
    }
  }

  /**
   * Avanzar manualmente a siguiente canci√≥n
   */
  async next() {
    console.log('‚è≠Ô∏è Avance manual solicitado');
    return await this.handleSongEnd();
  }

  /**
   * Seleccionar siguiente canci√≥n seg√∫n prioridades
   */
  async selectNextSong() {
    try {
      console.log('üéØ Seleccionando siguiente canci√≥n...');
      console.log('üîç DEBUG - Estado actual del AutoDJ:', {
        isInInterrupt: this.isInInterrupt,
        interruptType: this.interruptType,
        globalRotationCounter: this.globalRotationCounter,
        rotationPlaylistsCount: this.rotationPlaylists.length,
        intervalPlaylistsCount: this.intervalPlaylists.length
      });

      // 0) Verificar si alg√∫n intervalo debe dispararse ahora (seg√∫n contadores)
      const intervalImmediate = await this.checkIntervalTrigger();
      if (intervalImmediate) {
        return intervalImmediate;
      }

      // 1) PRIORIDAD: Si hay intervalos pendientes, reproducir en orden (A ‚Üí B)
      if (this.pendingIntervalQueue.length > 0) {
        const nextInterval = this.pendingIntervalQueue.shift();
        console.log('üéØ Intervalo pendiente detectado, playlist:', nextInterval?.nombre || nextInterval?.id);
        return await this.selectSongFromInterval(nextInterval);
      }

      // 2) PRIORIDAD BASE: Seleccionar de rotaci√≥n general
      console.log('üîç Seleccionando de rotaci√≥n general...');
      const rotationSong = await this.selectFromRotation();
      if (rotationSong) {
        console.log('‚úÖ Canci√≥n seleccionada de playlist ROTACI√ìN:', rotationSong?.canciones?.titulo || rotationSong?.titulo);
        console.log('üìä Playlist de origen:', {
          id: this.currentPlaylist?.id,
          nombre: this.currentPlaylist?.nombre,
          tipo: this.currentPlaylist?.tipo
        });
        return rotationSong;
      }
      
      console.error('‚ùå No se pudo seleccionar ninguna canci√≥n de ninguna categor√≠a');
      return null;
      
    } catch (error) {
      console.error('‚ùå Error seleccionando siguiente canci√≥n:', error);
      // Fallback: intentar rotaci√≥n general
      console.log('üîÑ Fallback: intentando solo rotaci√≥n general...');
      return await this.selectFromRotation();
    }
  }

  /**
   * Verificar si hay playlists agendadas activas
   */
  async checkScheduledPlaylists() { return null; }

  /**
   * Verificar si una playlist agendada est√° activa
   */
  isScheduledPlaylistActive() { return false; }

  /**
   * Formatear fecha para comparaci√≥n (DD/MM/YYYY -> YYYY-MM-DD)
   */
  formatDateForComparison(dateString) {
    if (!dateString) return null;
    
    // Si ya est√° en formato YYYY-MM-DD, retornar tal cual
    if (dateString.includes('-') && dateString.length === 10) {
      return dateString;
    }
    
    // Si est√° en formato DD/MM/YYYY, convertir
    if (dateString.includes('/')) {
      const [day, month, year] = dateString.split('/');
      return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
    }
    
    return dateString;
  }

  /**
   * Verificar si debe activarse una playlist de intervalo
   */
  async checkIntervalTrigger() {
    // Nuevo flujo: usar contadores por playlist y construir cola de ejecuci√≥n
    if (this.isInInterrupt) return null;
    
    const triggered = [];
    for (const playlist of this.intervalPlaylists) {
      // üîß DEBUG espec√≠fico para MUSICA EN CHINO
      if (playlist.nombre === 'MUSICA EN CHINO') {
        const now = new Date();
        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        const isOperational = this.isPlaylistOperationalNow(playlist);
        // Calcular conversi√≥n UTC ‚Üí Local para debug
        const activaDesdeUTC = playlist.activa_desde ? new Date(playlist.activa_desde) : null;
        const activaHastaUTC = playlist.activa_hasta ? new Date(playlist.activa_hasta) : null;
        const startLocal = activaDesdeUTC ? new Date(activaDesdeUTC.getTime() + (now.getTimezoneOffset() * 60000)) : null;
        const endLocal = activaHastaUTC ? new Date(activaHastaUTC.getTime() + (now.getTimezoneOffset() * 60000)) : null;
        
        console.log('üéµ DEBUG MUSICA EN CHINO en checkIntervalTrigger:', {
          nombre: playlist.nombre,
          // Timestamps originales (UTC)
          activa_desde_utc: playlist.activa_desde,
          activa_hasta_utc: playlist.activa_hasta,
          // Conversi√≥n a hora local para comparaci√≥n
          franja_local_inicio: startLocal ? `${startLocal.getHours().toString().padStart(2, '0')}:${startLocal.getMinutes().toString().padStart(2, '0')}` : null,
          franja_local_fin: endLocal ? `${endLocal.getHours().toString().padStart(2, '0')}:${endLocal.getMinutes().toString().padStart(2, '0')}` : null,
          // Hora actual
          hora_local_actual: currentTime,
          // Estado
          isOperational: isOperational,
          repetir_cada: playlist.repetir_cada,
          repetir_unidad: playlist.repetir_unidad,
          contador_actual: this.intervalCounters.get(playlist.id) || 0,
          resultado: !isOperational ? '‚ùå INACTIVA' : '‚úÖ ACTIVA'
        });
      }
      
      if (!this.isPlaylistOperationalNow(playlist)) continue;
      const count = Number(this.intervalCounters.get(playlist.id) ?? 0);
      const unidad = (playlist.repetir_unidad || '').toString().toLowerCase();
      const threshold = Number(playlist.repetir_cada ?? 0);
      if (!Number.isFinite(threshold) || threshold <= 0) continue;
      if (unidad === 'canciones' && count >= threshold) {
        console.log('üéØ Intervalo listo para disparar:', {
          playlist: playlist.nombre,
          count,
          threshold
        });
        triggered.push(playlist);
      }
    }

    if (triggered.length > 0) {
      // Ordenar por repetir_cada ascendente para A ‚Üí B
      triggered.sort((a, b) => (a.repetir_cada || 0) - (b.repetir_cada || 0));
      this.pendingIntervalQueue.push(...triggered);
      // Resetear contadores de los que entran a cola
      triggered.forEach(p => this.intervalCounters.set(p.id, 0));
      const nextInterval = this.pendingIntervalQueue.shift();
      console.log('üîÅ Activando playlist de intervalo:', nextInterval?.nombre);
      return await this.selectSongFromInterval(nextInterval);
    }
    return null;
  }

  /**
   * Verificar si debe activarse un intervalo espec√≠fico
   */
  shouldTriggerInterval() { return false; }

  /**
   * Obtener raz√≥n por la que no se activa una playlist de intervalo
   */
  getIntervalTriggerReason(playlist) {
    // Verificar franja horaria si est√° habilitada
    if (playlist.usar_franja_horaria && !this.isInActiveTimeFrame(playlist)) {
      return `Fuera de franja horaria (${playlist.franja_inicio} - ${playlist.franja_fin})`;
    }
    
    // Verificar contador seg√∫n unidad
    if (playlist.repetir_unidad === 'canciones') {
      const faltan = playlist.repetir_cada - this.globalRotationCounter;
      return `Contador insuficiente (${this.globalRotationCounter}/${playlist.repetir_cada}, faltan ${faltan} canciones)`;
    }
    
    return `Unidad no soportada: ${playlist.repetir_unidad}`;
  }

  /**
   * Verificar si una playlist est√° en su franja horaria activa
   */
  isInActiveTimeFrame(playlist) {
    // üîß CORREGIDO: Verificar tanto campos nuevos como antiguos
    const hasOldFormat = playlist.usar_franja_horaria && (playlist.franja_inicio || playlist.franja_fin);
    const hasNewFormat = playlist.activa_desde || playlist.activa_hasta;
    
    if (!hasOldFormat && !hasNewFormat) return true;
    
    const now = new Date();
    
    // Formato nuevo: activa_desde y activa_hasta (timestamps)
    if (hasNewFormat) {
      const activaDesde = playlist.activa_desde ? new Date(playlist.activa_desde) : null;
      const activaHasta = playlist.activa_hasta ? new Date(playlist.activa_hasta) : null;
      
      // üîß CASO ESPECIAL: Si ambas fechas son iguales, significa "siempre activa"
      if (activaDesde && activaHasta && activaDesde.getTime() === activaHasta.getTime()) {
        // üîß CORREGIDO: Solo loggear una vez por playlist para evitar spam
        const cacheKey = `always_active_${playlist.id}`;
        if (!this.timeFrameCache || !this.timeFrameCache[cacheKey]) {
          if (!this.timeFrameCache) this.timeFrameCache = {};
          this.timeFrameCache[cacheKey] = true;
          console.log('üïê Playlist siempre activa detectada:', playlist.nombre, '(activa_desde === activa_hasta)');
        }
        return true;
      }
      
      // üîß CORRECCI√ìN: Comparar solo las horas/minutos, no fechas completas
      // El admin guarda hora local ‚Üí UTC, el reproductor debe interpretar UTC ‚Üí hora local
      if (activaDesde && activaHasta) {
        const currentHours = now.getHours();
        const currentMinutes = now.getMinutes();
        const currentTimeInMinutes = currentHours * 60 + currentMinutes;
        
        // Convertir timestamps UTC a hora local para comparaci√≥n
        const startLocalTime = new Date(activaDesde.getTime() + (now.getTimezoneOffset() * 60000));
        const endLocalTime = new Date(activaHasta.getTime() + (now.getTimezoneOffset() * 60000));
        
        const startMinutes = startLocalTime.getHours() * 60 + startLocalTime.getMinutes();
        const endMinutes = endLocalTime.getHours() * 60 + endLocalTime.getMinutes();
        
        if (startMinutes <= endMinutes) {
          // Franja normal (ej: 15:00 - 17:00)
          return currentTimeInMinutes >= startMinutes && currentTimeInMinutes <= endMinutes;
        } else {
          // Franja que cruza medianoche (ej: 23:00 - 06:00)
          return currentTimeInMinutes >= startMinutes || currentTimeInMinutes <= endMinutes;
        }
      }
      
      return true;
    }
    
    // Formato antiguo: franja_inicio y franja_fin (HH:MM)
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const timeToMinutes = (hhmm) => {
      if (!hhmm) return null;
      const [h, m] = hhmm.split(':').map(Number);
      return h * 60 + m;
    };
    const startMinutes = timeToMinutes(playlist.franja_inicio);
    const endMinutes = timeToMinutes(playlist.franja_fin);
    if (startMinutes == null || endMinutes == null) return true;
    if (startMinutes <= endMinutes) {
      return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
    } else {
      return currentMinutes >= startMinutes || currentMinutes <= endMinutes;
    }
  }

  /**
   * Convertir tiempo HH:MM a minutos desde medianoche
   */
  timeToMinutes(timeString) {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
  }

  /**
   * Seleccionar canci√≥n de playlist agendada
   */
  async selectSongFromScheduled(playlist) {
    console.log('üìÖ Seleccionando de playlist agendada:', playlist.nombre);
    
    // Guardar estado de rotaci√≥n para retorno
    this.saveRotationState();
    this.isInInterrupt = true;
    this.interruptType = 'scheduled';
    
    return await this.loadPlaylistAndSelectSong(playlist);
  }

  /**
   * Seleccionar canci√≥n de playlist de intervalo
   */
  async selectSongFromInterval(playlist) {
    console.log('üîÅ Seleccionando de playlist de intervalo:', playlist.nombre);
    
    // Guardar estado de rotaci√≥n para retorno
    this.saveRotationState();
    this.isInInterrupt = true;
    this.interruptType = 'interval';
    
    // Reiniciar contador de rotaci√≥n
    this.globalRotationCounter = 0;
    console.log('üîÑ Contador de rotaci√≥n reiniciado');
    
    return await this.loadPlaylistAndSelectSong(playlist);
  }

  /**
   * Seleccionar canci√≥n de rotaci√≥n general (ponderada por peso)
   */
  async selectFromRotation() {
    console.log('üåÄ Seleccionando de rotaci√≥n general...');
    
    // Si estamos saliendo de una interrupci√≥n, restaurar estado
    if (this.isInInterrupt) {
      this.restoreRotationState();
    }
    
    // Obtener playlists de rotaci√≥n activas en franja horaria actual
    let activePlaylists = this.getActiveRotationPlaylists();
    
    // üîß FALLBACK: Si no hay playlists activas en franja horaria, usar todas las activas
    if (activePlaylists.length === 0) {
      console.log('‚ö†Ô∏è No hay playlists de rotaci√≥n en franja horaria, usando fallback...');
      activePlaylists = this.rotationPlaylists.filter(playlist => playlist?.activa === true || playlist?.activa === 1);
      
      if (activePlaylists.length === 0) {
        throw new Error('No hay playlists de rotaci√≥n activas en este canal');
      }
      
      console.log('üîÑ Fallback: usando playlists activas sin restricci√≥n horaria:', activePlaylists.map(p => p.nombre));
    }
    
    // Seleccionar playlist ponderada por peso
    const selectedPlaylist = this.selectPlaylistByWeight(activePlaylists);
    console.log('üéØ Playlist seleccionada:', selectedPlaylist.nombre, 'peso:', selectedPlaylist.peso);
    
    return await this.loadPlaylistAndSelectSong(selectedPlaylist);
  }

  /**
   * Obtener playlists de rotaci√≥n activas en la franja horaria actual
   */
  getActiveRotationPlaylists() {
    return this.rotationPlaylists.filter(playlist => this.isPlaylistOperationalNow(playlist));
  }

  /**
   * Seleccionar playlist usando distribuci√≥n ponderada por peso
   */
  selectPlaylistByWeight(playlists) {
    // Calcular peso total
    const totalWeight = playlists.reduce((sum, playlist) => sum + playlist.peso, 0);
    
    // Generar n√∫mero aleatorio entre 1 y totalWeight
    const random = Math.floor(Math.random() * totalWeight) + 1;
    
    // Seleccionar playlist seg√∫n peso acumulado
    let weightSum = 0;
    for (const playlist of playlists) {
      weightSum += playlist.peso;
      if (random <= weightSum) {
        return playlist;
      }
    }
    
    // Fallback (no deber√≠a llegar aqu√≠)
    return playlists[0];
  }

  /**
   * Cargar playlist y seleccionar canci√≥n seg√∫n configuraci√≥n
   */
  async loadPlaylistAndSelectSong(playlist) {
    try {
      console.log('üéµ Cargando canciones de playlist:', playlist.nombre);
      console.log('üîç DEBUG - Detalles de playlist a cargar:', {
        id: playlist.id,
        nombre: playlist.nombre,
        tipo: playlist.tipo,
        activa: playlist.activa,
        peso: playlist.peso,
        orden: playlist.orden,
        canal_id: playlist.canal_id,
        uso_en_autodj: playlist.uso_en_autodj
      });
      
      // üö® VERIFICACI√ìN CR√çTICA: ¬øLa playlist pertenece al canal actual?
      const currentChannelId = this.currentChannel?.id;
      if (playlist.canal_id && playlist.canal_id !== currentChannelId) {
        console.error('üö® ERROR CR√çTICO - Playlist de canal incorrecto:', {
          playlistNombre: playlist.nombre,
          playlistCanalId: playlist.canal_id,
          currentChannelId: currentChannelId,
          currentChannelName: this.currentChannel?.nombre
        });
        throw new Error(`Playlist "${playlist.nombre}" pertenece al canal ${playlist.canal_id}, no al canal actual ${currentChannelId}`);
      }
      
      // Cargar canciones de la playlist
      const songs = await songsApi.getPlaylistSongs(playlist.id);
      
      console.log('üìÇ Cargando canciones de playlist:', playlist.nombre, `(${songs?.length || 0} canciones)`);
      
      if (!songs || songs.length === 0) {
        console.warn('‚ö†Ô∏è Playlist vac√≠a:', playlist.nombre);
        console.warn('üîç DEBUG - Playlist vac√≠a detalles:', {
          playlistId: playlist.id,
          apiResponse: songs,
          reason: 'No songs returned from API'
        });
        return null;
      }

      // ‚úÖ NUEVO MODELO: Las canciones son globales, pertenencia v√≠a playlists
      console.log('‚úÖ Usando modelo de canciones globales - playlist ya filtrada por canal');
      
      // Todas las canciones de la playlist son v√°lidas (playlist.canal_id ya las filtra)
      const filteredSongs = songs.filter(song => {
        // Solo verificaciones b√°sicas de integridad
        const hasValidData = song?.canciones?.titulo && song?.canciones?.url_s3;
        
        if (!hasValidData) {
          console.warn('üö´ Canci√≥n filtrada (datos incompletos):', {
            songTitle: song?.canciones?.titulo || 'Sin t√≠tulo',
            hasUrl: !!song?.canciones?.url_s3,
            hasTitle: !!song?.canciones?.titulo
          });
        }
        
        return hasValidData;
      });

      console.log('üìä Filtrado de canciones:', {
        original: songs.length,
        v√°lidas: filteredSongs.length,
        filtradas: songs.length - filteredSongs.length,
        playlist: playlist.nombre
      });
      
      if (filteredSongs.length === 0) {
        console.error('‚ùå No hay canciones v√°lidas del canal actual en playlist:', playlist.nombre);
        console.error('üîç DEBUG - Todas las canciones pertenecen a otros canales:', {
          playlistId: playlist.id,
          playlistName: playlist.nombre,
          currentChannelId,
          songChannels: songs.map(s => s?.canciones?.canal_id).filter((id, i, arr) => arr.indexOf(id) === i)
        });
        return null;
      }
      
      this.currentPlaylist = playlist;
      this.playQueue = filteredSongs; // Usar canciones filtradas
      
      // Seleccionar canci√≥n seg√∫n orden configurado
      let selectedSong;
      
      if (playlist.orden === 'aleatorio') {
        // üîß NUEVO: Filtrar canciones para evitar repeticiones recientes
        const songsWithoutRepetitions = this.filterRecentlyPlayedSongs(filteredSongs);
        
        // Selecci√≥n aleatoria de las canciones disponibles (sin repeticiones recientes)
        const randomIndex = Math.floor(Math.random() * songsWithoutRepetitions.length);
        selectedSong = songsWithoutRepetitions[randomIndex];
        
        // Encontrar el √≠ndice original en la lista completa para mantener compatibilidad
        this.currentSongIndex = filteredSongs.findIndex(song => 
          (song?.canciones?.id || song?.id) === (selectedSong?.canciones?.id || selectedSong?.id)
        );
        
        console.log('üé≤ Selecci√≥n aleatoria (sin repeticiones):', {
          randomIndex,
          originalIndex: this.currentSongIndex,
          posicionEnAdmin: this.currentSongIndex + 1, // üîß NUEVO: Posici√≥n visual (base-1) como se ve en el admin
          totalSongs: filteredSongs.length,
          availableSongs: songsWithoutRepetitions.length,
          selectedTitle: selectedSong?.canciones?.titulo || selectedSong?.titulo,
          avoidedRepetitions: filteredSongs.length - songsWithoutRepetitions.length
        });
      } else {
        // Selecci√≥n secuencial
        if (this.currentSongIndex >= filteredSongs.length) {
          this.currentSongIndex = 0; // Reiniciar al principio
          console.log('üîÑ Reiniciando √≠ndice secuencial al principio');
        }
        selectedSong = filteredSongs[this.currentSongIndex];
        console.log('üìã Selecci√≥n secuencial:', {
          currentIndex: this.currentSongIndex,
          posicionEnAdmin: this.currentSongIndex + 1, // üîß NUEVO: Posici√≥n visual (base-1) como se ve en el admin
          totalSongs: filteredSongs.length,
          selectedTitle: selectedSong?.canciones?.titulo || selectedSong?.titulo
        });
      }
      
      // ‚úÖ NUEVO MODELO: Verificaci√≥n simplificada sin canal_id
      const finalChannelCheck = true; // Siempre v√°lido si viene de playlist del canal
      
      console.log('‚úÖ Canci√≥n seleccionada desde playlist:', {
        playlist: playlist.nombre,
        playlistType: playlist.tipo,
        songTitle: selectedSong?.canciones?.titulo || selectedSong?.titulo || 'Sin t√≠tulo',
        songArtist: selectedSong?.canciones?.artista || selectedSong?.artista || 'Sin artista',
        songChannelId: selectedSong?.canciones?.canal_id,
        currentChannelId,
        selectionMethod: playlist.orden,
        indiceArray: this.currentSongIndex, // üîß NUEVO: √çndice en el array (base-0)
        posicionAdmin: this.currentSongIndex + 1, // üîß NUEVO: Posici√≥n como se ve en el admin (base-1)
        posicionDB: selectedSong?.posicion || 'N/A', // üîß NUEVO: Posici√≥n real en la base de datos
        finalChannelCheck: finalChannelCheck ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'
      });
      
              // PROTECCI√ìN ABSOLUTA - Si la canci√≥n final no es del canal correcto, ERROR CR√çTICO
        if (!finalChannelCheck) {
          console.error('üö® ERROR CR√çTICO: Canci√≥n del canal incorrecto a punto de ser retornada!', {
            songTitle: selectedSong?.canciones?.titulo,
            songChannelId: selectedSong?.canciones?.canal_id,
            currentChannelId,
            playlistName: playlist.nombre,
            ACCION: 'SELECCI√ìN BLOQUEADA + LIMPIEZA DE EMERGENCIA'
          });
          
          // Activar limpieza de emergencia
          setTimeout(() => {
            this.emergencyChannelCleanup(`Canci√≥n incorrecta detectada: ${selectedSong?.canciones?.titulo} (canal ${selectedSong?.canciones?.canal_id} ‚â† ${currentChannelId})`);
          }, 100);
          
          // NO retornar la canci√≥n incorrecta
          return null;
        }
      
      // üîß NUEVO: Agregar la canci√≥n seleccionada al historial para evitar futuras repeticiones
      this.addSongToHistory(selectedSong);
      
      return selectedSong;
      
    } catch (error) {
      console.error('‚ùå Error cargando playlist:', error);
      console.error('üîç DEBUG - Error detalles:', {
        playlistId: playlist?.id,
        playlistName: playlist?.nombre,
        errorMessage: error.message,
        errorStack: error.stack
      });
      return null;
    }
  }

  /**
   * FUNCI√ìN DE EMERGENCIA: Limpiar completamente el estado cuando se detectan errores de canal
   */
  async emergencyChannelCleanup(reason) {
    console.error('üö® ACTIVANDO LIMPIEZA DE EMERGENCIA:', reason);
    
    // 1. Limpiar estado del reproductor de audio
    const cleaned = audioPlayer.forceCleanIncorrectPreloadedSong();
    if (cleaned) {
      console.log('üßπ Canci√≥n precargada incorrecta eliminada');
    }
    
    // 2. Limpiar queue actual
    this.playQueue = [];
    this.currentSong = null;
    this.currentSongIndex = 0;
    
    // 3. Forzar recarga de playlists del canal
    console.log('üîÑ Forzando recarga de playlists del canal actual...');
    await this.loadChannelPlaylists();
    
    // 4. Seleccionar nueva canci√≥n limpia
    console.log('üéØ Seleccionando nueva canci√≥n despu√©s de limpieza...');
    const newSong = await this.selectNextSong();
    
    if (newSong) {
      await this.loadAndPlaySong(newSong);
      console.log('‚úÖ Canci√≥n limpia cargada exitosamente');
    } else {
      console.error('‚ùå No se pudo cargar canci√≥n despu√©s de limpieza de emergencia');
    }
  }

  /**
   * Cargar canci√≥n sin reproducir autom√°ticamente
   */
  async loadSongOnly(song) {
    if (!song) return false;

    try {
      const songTitle = song?.canciones?.titulo || 'Sin t√≠tulo';
      console.log('üéµ Cargando canci√≥n:', songTitle);
      
      // Cargar canci√≥n en el reproductor
      const success = await audioPlayer.loadSong(song, false);
      
      if (success) {
        this.currentSong = song;
        
        // ‚úÖ OPTIMIZACI√ìN: NO precarga autom√°tica - solo just-in-time cuando sea necesario
        console.log('üìº Canci√≥n cargada SIN precarga autom√°tica (just-in-time activado)');
        
        return true;
      } else {
        console.warn('‚ö†Ô∏è Error cargando canci√≥n');
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå Error en loadSongOnly:', error);
      return false;
    }
  }

  /**
   * Cargar y reproducir canci√≥n seleccionada
   */
  async loadAndPlaySong(song) {
    if (!song) return false;

    // üîß CORREGIDO: Implementar debouncing para evitar cambios excesivos
    const now = Date.now();
    const timeSinceLastChange = now - this.lastSongChangeTime;
    
    if (timeSinceLastChange < this.minSongChangeInterval) {
      console.log(`‚è±Ô∏è Cambio de canci√≥n demasiado r√°pido (${timeSinceLastChange}ms < ${this.minSongChangeInterval}ms) - ignorando`);
      return false;
    }

    // Si requerimos interacci√≥n del usuario, solo cargar
    if (this.requiresUserInteraction) {
      console.log('üö´ Se requiere interacci√≥n del usuario, solo cargando canci√≥n');
      return await this.loadSongOnly(song);
    }

    try {
      const songTitle = song?.canciones?.titulo || 'Sin t√≠tulo';
      console.log('üéµ Cargando y reproduciendo:', songTitle);
      
      // üîß CORREGIDO: Actualizar timestamp del √∫ltimo cambio
      this.lastSongChangeTime = now;
      
      // Cargar canci√≥n en el reproductor
      const success = await audioPlayer.loadSong(song, false);
      
      if (success) {
        this.currentSong = song;
        
        // üîß SISTEMA H√çBRIDO: Precarga autom√°tica si ya est√° activada, just-in-time si no
        if (this.smartPreloadEnabled) {
          console.log('üéØ Canci√≥n cargada - Precarga autom√°tica ACTIVADA');
          // üîß NUEVO: Precarga con manejo de errores mejorado
          setTimeout(async () => {
            try {
              await this.preloadNextSong();
            } catch (preloadError) {
              console.log('‚ÑπÔ∏è Error en precarga autom√°tica (no cr√≠tico):', preloadError.message);
              // No afectar la reproducci√≥n por errores de precarga
            }
          }, 1500); // Precarga autom√°tica tras carga exitosa
        } else {
          console.log('üìº Canci√≥n cargada - Just-in-time STANDBY (esperando primera reproducci√≥n)');
        }
        
        // üîß MEJORADO: Iniciar reproducci√≥n autom√°ticamente cuando se carga una nueva canci√≥n
        // desde handleSongEnd (transici√≥n autom√°tica)
        if (!this.requiresUserInteraction) {
          console.log('‚ñ∂Ô∏è Iniciando reproducci√≥n autom√°tica de nueva canci√≥n');
          await audioPlayer.play();
        } else {
          console.log('‚ÑπÔ∏è Canci√≥n cargada pero esperando interacci√≥n del usuario para reproducir');
        }
        
        return true;
      } else {
        console.warn('‚ö†Ô∏è Error cargando canci√≥n, intentando siguiente...');
        if (!this.isInErrorState) {
          return await this.handleSongEnd();
        }
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå Error en loadAndPlaySong:', error);
      if (!this.isInErrorState) {
        return await this.handleSongEnd();
      }
      return false;
    }
  }

  /**
   * Precargar siguiente canci√≥n para crossfade
   */
  async preloadNextSong() {
    try {
      // üîß NUEVO: Verificar si el crossfade est√° habilitado antes de intentar precargar
      const audioState = audioPlayer.getState();
      if (!audioState.crossfadeEnabled) {
        console.log('‚ÑπÔ∏è Precarga saltada - crossfade desactivado (no es necesario precargar)');
        return;
      }
      
      // Determinar raz√≥n de la precarga
      const preloadReason = this.smartPreloadEnabled ? 'AUTO (usuario activo)' : 'JUST-IN-TIME';
      console.log(`üîÑ Iniciando precarga (${preloadReason})...`);
      
      // No precargar si estamos en estado de error
      if (this.isInErrorState || this.requiresUserInteraction) {
        console.log('‚è∏Ô∏è Precarga pausada: estado de error o se requiere interacci√≥n');
        return;
      }

      // Throttling para evitar bucles de precarga
      const now = Date.now();
      if (this.lastPreloadAttempt && (now - this.lastPreloadAttempt) < 3000) {
        console.log('‚è∏Ô∏è Precarga throttled - demasiados intentos recientes');
        return;
      }
      this.lastPreloadAttempt = now;
      
      // Si ya hay siguiente canci√≥n precargada, no hacer nada
      if (audioState.nextSongLoaded) {
        console.log('üìÄ Siguiente canci√≥n ya est√° precargada');
        return;
      }

      const nextSong = await this.peekNextSong();
      if (!nextSong) {
        console.log('üì≠ No hay siguiente canci√≥n para precargar');
        return;
      }

      const nextTitle = nextSong?.canciones?.titulo || nextSong?.titulo || 'Sin t√≠tulo';
      console.log(`üéµ Precargando (${preloadReason}):`, nextTitle);
      
      const success = await audioPlayer.preloadNextSong(nextSong);
      if (success) {
        console.log(`‚úÖ Precarga ${preloadReason} exitosa:`, nextTitle);
        // Resetear contador de errores si la precarga fue exitosa
        this.preloadErrorCount = 0;
      } else {
        // üîß NUEVO: Manejo inteligente de errores de precarga
        console.warn(`‚ö†Ô∏è Error en precarga ${preloadReason}:`, nextTitle);
        
        // üîß MEJORADO: Verificar si el crossfade est√° desactivado en audioPlayerService
        const audioState = audioPlayer.getState();
        if (!audioState.crossfadeEnabled) {
          console.log('‚ÑπÔ∏è Error de precarga ignorado - crossfade desactivado (comportamiento normal)');
          this.preloadErrorCount = 0; // Resetear contador ya que es un error esperado
          return;
        }
        
        // Incrementar contador de errores de precarga solo para errores reales
        this.preloadErrorCount = (this.preloadErrorCount || 0) + 1;
        if (this.preloadErrorCount >= 3) {
          console.warn('üö´ Demasiados errores de precarga, pausando precargas por 30 segundos');
          this.lastPreloadAttempt = now + 25000; // Pausar 30 segundos adicionales
          this.preloadErrorCount = 0;
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error en preloadNextSong:', error);
      // No propagar el error para evitar bucles
      this.preloadErrorCount = (this.preloadErrorCount || 0) + 1;
    }
  }

  /**
   * Obtener siguiente canci√≥n sin avanzar √≠ndice (para precarga)
   */
  async peekNextSong() {
    try {
      // L√≥gica simplificada para obtener la siguiente canci√≥n
      // Sin modificar el estado actual del AutoDJ
      
      const currentChannelId = this.currentChannel?.id;
      if (!currentChannelId) {
        console.warn('‚ö†Ô∏è No hay canal actual para peekNextSong');
        return null;
      }
      
      // Si tenemos una playlist actual con canciones, usar la siguiente de esa playlist
      if (this.currentPlaylist && this.playQueue && this.playQueue.length > 0) {
        const nextIndex = (this.currentSongIndex + 1) % this.playQueue.length;
        const nextSong = this.playQueue[nextIndex];
        
        // VERIFICACI√ìN ESTRICTA que la canci√≥n pertenezca al canal actual
        const channelMatch = nextSong?.canciones?.canal_id === currentChannelId;
        
        console.log('üîç peekNextSong - Verificando siguiente de playlist actual:', {
          title: nextSong?.canciones?.titulo,
          songChannelId: nextSong?.canciones?.canal_id,
          currentChannelId,
          match: channelMatch ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO',
          playlist: this.currentPlaylist?.nombre
        });
        
        if (channelMatch) {
          console.log('‚úÖ peekNextSong - Siguiente de playlist actual autorizada');
          return nextSong;
        } else {
          console.error('üö´ ERROR: peekNextSong - Canci√≥n de playlist NO pertenece al canal actual:', {
            title: nextSong?.canciones?.titulo,
            songChannelId: nextSong?.canciones?.canal_id,
            currentChannelId,
            playlistName: this.currentPlaylist?.nombre,
            PROBLEMA: 'Playlist contaminada con canciones de otros canales'
          });
          
          // Activar limpieza de emergencia por playlist contaminada
          setTimeout(() => {
            this.emergencyChannelCleanup(`Playlist contaminada detectada: ${this.currentPlaylist?.nombre} contiene canci√≥n ${nextSong?.canciones?.titulo} del canal ${nextSong?.canciones?.canal_id}`);
          }, 100);
        }
      }

      // Si no hay playlist actual o se acab√≥, intentar seleccionar de rotaci√≥n
      if (this.rotationPlaylists && this.rotationPlaylists.length > 0) {
        // Seleccionar playlist aleatoria ponderada (simplificado)
        const randomPlaylist = this.rotationPlaylists[Math.floor(Math.random() * this.rotationPlaylists.length)];
        
        console.log('üîç peekNextSong - Cargando de playlist de rotaci√≥n:', {
          playlistName: randomPlaylist.nombre,
          playlistId: randomPlaylist.id
        });
        
        // Cargar canciones de esa playlist
        const songs = await songsApi.getPlaylistSongs(randomPlaylist.id);
        if (songs && songs.length > 0) {
          // ‚úÖ NUEVO MODELO: Canciones globales, no filtrar por canal_id
          const filteredSongs = songs.filter(song => {
            // Solo verificaciones b√°sicas de integridad
            const hasValidData = song?.canciones?.titulo && song?.canciones?.url_s3;
            
            if (!hasValidData) {
              console.warn('üö´ peekNextSong - Canci√≥n filtrada (datos incompletos):', {
                songTitle: song?.canciones?.titulo || 'Sin t√≠tulo',
                hasUrl: !!song?.canciones?.url_s3
              });
            }
            
            return hasValidData;
          });
          
          console.log('üìä peekNextSong - Filtrado de canciones:', {
            originalCount: songs.length,
            filteredCount: filteredSongs.length,
            playlistName: randomPlaylist.nombre
          });
          
          if (filteredSongs.length > 0) {
            const randomSong = filteredSongs[Math.floor(Math.random() * filteredSongs.length)];
            
            // ‚úÖ NUEVO MODELO: Verificaci√≥n simplificada para peekNextSong
            const finalChannelCheck = true; // Siempre v√°lido si viene de playlist del canal
            
            console.log('‚úÖ peekNextSong - Canci√≥n seleccionada:', {
              title: randomSong?.canciones?.titulo,
              channelId: randomSong?.canciones?.canal_id,
              currentChannelId,
              playlist: randomPlaylist.nombre,
              finalChannelCheck: finalChannelCheck ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'
            });
            
            // PROTECCI√ìN ABSOLUTA tambi√©n en peekNextSong
            if (!finalChannelCheck) {
              console.error('üö® ERROR CR√çTICO en peekNextSong: Canci√≥n del canal incorrecto!', {
                songTitle: randomSong?.canciones?.titulo,
                songChannelId: randomSong?.canciones?.canal_id,
                currentChannelId,
                playlistName: randomPlaylist.nombre,
                ACCION: 'PEEK BLOQUEADO + LIMPIEZA DE EMERGENCIA'
              });
              
              // Activar limpieza de emergencia
              setTimeout(() => {
                this.emergencyChannelCleanup(`peekNextSong detect√≥ canci√≥n incorrecta: ${randomSong?.canciones?.titulo} (canal ${randomSong?.canciones?.canal_id} ‚â† ${currentChannelId})`);
              }, 100);
              
              return null;
            }
            
            return randomSong;
          } else {
            console.warn('‚ö†Ô∏è peekNextSong - No hay canciones v√°lidas del canal actual en playlist:', randomPlaylist.nombre);
          }
        }
      }

      console.warn('üì≠ peekNextSong - No se pudo encontrar siguiente canci√≥n del canal actual');
      return null;
    } catch (error) {
      console.warn('‚ö†Ô∏è Error en peekNextSong:', error);
      return null;
    }
  }

  /**
   * Guardar estado actual para peek
   */
  saveCurrentState() {
    return {
      currentSongIndex: this.currentSongIndex,
      globalRotationCounter: this.globalRotationCounter,
      isInInterrupt: this.isInInterrupt,
      interruptType: this.interruptType
    };
  }

  /**
   * Restaurar estado despu√©s de peek
   */
  restoreCurrentState(state) {
    this.currentSongIndex = state.currentSongIndex;
    this.globalRotationCounter = state.globalRotationCounter;
    this.isInInterrupt = state.isInInterrupt;
    this.interruptType = state.interruptType;
  }

  /**
   * Manejar fin de canci√≥n y avanzar
   */
  async handleSongEnd() {
    // üîß NUEVO: Protecci√≥n contra ejecuciones concurrentes
    if (this.isHandlingSongEnd) {
      console.log('‚è∏Ô∏è handleSongEnd ya en ejecuci√≥n, saltando...');
      return;
    }
    
    this.isHandlingSongEnd = true;
    
    try {
      // No procesar si estamos en estado de error o requerimos interacci√≥n
      if (this.isInErrorState || this.requiresUserInteraction) {
        console.log('‚è∏Ô∏è handleSongEnd pausado por estado de error o requerimiento de interacci√≥n');
        return;
      }
      
      console.log('üéµ AutoDJ: handleSongEnd iniciado');
      
      // Avanzar √≠ndice de canci√≥n actual
      this.currentSongIndex++;
      
      // Verificar si debe terminar interrupci√≥n
      if (this.isInInterrupt && this.shouldEndInterrupt()) {
        console.log('üîö Finalizando interrupci√≥n, volviendo a rotaci√≥n general');
        this.endInterrupt();
      }
      
      // Seleccionar siguiente canci√≥n
      const nextSong = await this.selectNextSong();
      if (nextSong) {
        await this.loadAndPlaySong(nextSong);
      } else {
        console.error('‚ùå No se pudo seleccionar siguiente canci√≥n');
      }
      
    } catch (error) {
      console.error('‚ùå Error en handleSongEnd:', error);
      
      // Evitar bucles infinitos en handleSongEnd
      this.errorCount++;
      if (this.errorCount >= this.maxErrors) {
        this.stopErrorLoop();
      }
    } finally {
      // üîß NUEVO: Siempre resetear el flag al finalizar
      this.isHandlingSongEnd = false;
    }
  }

  /**
   * Verificar si debe terminar la interrupci√≥n actual
   */
  shouldEndInterrupt() {
    if (!this.isInInterrupt || !this.currentPlaylist) return false;
    
    const playlist = this.currentPlaylist;
    
    if (playlist.tipo === 'intervalo') {
      // Para intervalos, terminar seg√∫n estilo_reproduccion
      if (playlist.estilo_reproduccion === 'aleatorio') {
        return true; // Solo una canci√≥n
      } else {
        return this.currentSongIndex >= this.playQueue.length; // Todas las canciones
      }
    }
    
    if (playlist.tipo === 'agendada') {
      // üîß MEJORADO: L√≥gica espec√≠fica para interrupciones agendadas
      console.log('üìÖ Verificando fin de interrupci√≥n agendada:', {
        playlist: playlist.nombre,
        currentSongIndex: this.currentSongIndex,
        playQueueLength: this.playQueue.length,
        estilo_reproduccion: playlist.estilo_reproduccion
      });
      
      if (playlist.estilo_reproduccion === 'aleatorio') {
        // Si es aleatorio, solo una canci√≥n
        console.log('üé≤ Interrupci√≥n agendada aleatoria - terminando despu√©s de una canci√≥n');
        return true;
      } else {
        // Si es secuencial, todas las canciones de la playlist
        const shouldEnd = this.currentSongIndex >= this.playQueue.length;
        console.log('üìã Interrupci√≥n agendada secuencial:', {
          shouldEnd,
          currentSongIndex: this.currentSongIndex,
          playQueueLength: this.playQueue.length
        });
        return shouldEnd;
      }
    }
    
    return false;
  }

  /**
   * Guardar estado de rotaci√≥n antes de interrupci√≥n
   */
  saveRotationState() {
    this.previousRotationState = {
      playlist: this.currentPlaylist,
      songIndex: this.currentSongIndex,
      playQueue: [...this.playQueue]
    };
    
    console.log('üíæ Estado de rotaci√≥n guardado');
  }

  /**
   * Restaurar estado de rotaci√≥n despu√©s de interrupci√≥n
   */
  restoreRotationState() {
    if (this.previousRotationState) {
      console.log('üîÑ Restaurando estado de rotaci√≥n');
      // No restaurar exactamente, sino continuar con algoritmo normal
      this.isInInterrupt = false;
      this.interruptType = null;
      this.previousRotationState = null;
    }
  }

  /**
   * Finalizar interrupci√≥n
   */
  endInterrupt() {
    console.log('üîö Finalizando interrupci√≥n:', this.interruptType);
    
    // üîß CR√çTICO: Si es interrupci√≥n de intervalo, limpiar cola para evitar duplicaciones
    if (this.interruptType === 'interval') {
      console.log('üßπ Limpiando cola de intervalos tras finalizar interrupci√≥n de intervalo');
      this.pendingIntervalQueue = [];
    }
    
    this.isInInterrupt = false;
    this.interruptType = null;
    this.currentPlaylist = null;
    this.playQueue = [];
    this.currentSongIndex = 0;
    this.previousRotationState = null;
    
    // Reportar estado final
    if (this.pendingIntervalQueue.length > 0) {
      console.log('üì¶ Intervalos en cola restantes:', this.pendingIntervalQueue.length);
    }
  }

  /**
   * Iniciar timers de verificaci√≥n autom√°tica
   */
  startTimers() {
    this.stopTimers(); // Limpiar anteriores
    
    // Timer de reloj local cada segundo para detectar transiciones de franja horaria
    this.clockTimer = setInterval(() => {
      if (this.isActive) {
        this.checkTimeFrameTransitions();
      }
    }, 1000);
    
    console.log('‚è∞ Timers iniciados (reloj local: 1s, sync: 5min)');
  }

  /**
   * Detener timers
   */
  stopTimers() {
    if (this.clockTimer) {
      clearInterval(this.clockTimer);
      this.clockTimer = null;
    }
  }

  /**
   * üîß NUEVO: Verificar playlists agendadas para interrupciones con crossfade
   */
  async checkScheduledPlaylistsForInterruption() {
    // No verificar si estamos en estado de error o ya en una interrupci√≥n
    if (this.isInErrorState || this.isInInterrupt) {
      return;
    }
    
    // Protecci√≥n: no ejecutar si hay selecci√≥n de canci√≥n en curso
    if (this.isHandlingSongEnd) {
      console.log('‚è∏Ô∏è Verificaci√≥n de agendadas pospuesta - selecci√≥n de canci√≥n en curso');
      return;
    }
    
    try {
      const now = new Date();
      const currentTime = now.getHours() * 60 + now.getMinutes();
      const currentDate = now.toISOString().split('T')[0];
      
      console.log('üìÖ Verificando playlists agendadas para interrupci√≥n:', {
        currentDate,
        currentTime: `${Math.floor(currentTime / 60)}:${currentTime % 60}`,
        totalScheduled: this.scheduledPlaylists.length
      });
      
      if (this.scheduledPlaylists.length === 0) {
        return;
      }
      
      for (const playlist of this.scheduledPlaylists) {
        console.log('üîç Analizando playlist agendada para interrupci√≥n:', {
          nombre: playlist.nombre,
          fecha: playlist.fecha,
          hora: playlist.hora,
          repetir_programacion: playlist.repetir_programacion,
          activa: playlist.activa,
          puede_interrumpirse: playlist.puede_interrumpirse
        });
        
        // Solo verificar playlists que pueden interrumpir
        if (playlist.puede_interrumpirse && this.isScheduledPlaylistActive(playlist, now, currentTime, currentDate)) {
          console.log('üé≠ ACTIVANDO INTERRUPCI√ìN AGENDADA CON CROSSFADE:', playlist.nombre);
          
          // Guardar estado de rotaci√≥n
          this.saveRotationState();
          this.isInInterrupt = true;
          this.interruptType = 'scheduled';
          
          // Seleccionar canci√≥n de la playlist agendada
          const selectedSong = await this.selectSongFromScheduledPlaylist(playlist);
          
          if (selectedSong) {
            console.log('üéµ Canci√≥n de interrupci√≥n seleccionada:', selectedSong?.canciones?.titulo || selectedSong?.titulo);
            
            // Iniciar crossfade de interrupci√≥n
            const success = await audioPlayer.startInterruptionCrossfade(selectedSong);
            
            if (success) {
              console.log('‚úÖ Crossfade de interrupci√≥n iniciado exitosamente');
              this.currentSong = selectedSong;
              this.currentPlaylist = playlist;
              return; // Solo una interrupci√≥n a la vez
            } else {
              console.warn('‚ö†Ô∏è Fallo en crossfade de interrupci√≥n, restaurando estado');
              this.restoreRotationState();
            }
          } else {
            console.warn('‚ö†Ô∏è No se pudo seleccionar canci√≥n de interrupci√≥n, restaurando estado');
            this.restoreRotationState();
          }
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error verificando playlists agendadas para interrupci√≥n:', error);
    }
  }

  /**
   * üîß NUEVO: Seleccionar canci√≥n de playlist agendada para interrupci√≥n
   */
  async selectSongFromScheduledPlaylist(playlist) {
    try {
      console.log('üìÖ Seleccionando canci√≥n de playlist agendada para interrupci√≥n:', playlist.nombre);
      
      // Cargar canciones de la playlist
      const songs = await songsApi.getPlaylistSongs(playlist.id);
      
      if (!songs || songs.length === 0) {
        console.warn('‚ö†Ô∏è Playlist agendada vac√≠a:', playlist.nombre);
        return null;
      }
      
      // Filtrar canciones del canal actual
      const currentChannelId = this.currentChannel?.id;
      const filteredSongs = songs.filter(song => {
        const songChannelId = song?.canciones?.canal_id;
        return songChannelId === currentChannelId;
      });
      
      if (filteredSongs.length === 0) {
        console.error('‚ùå No hay canciones v√°lidas del canal actual en playlist agendada:', playlist.nombre);
        return null;
      }
      
      // Seleccionar canci√≥n seg√∫n orden configurado
      let selectedSong;
      
      if (playlist.orden === 'aleatorio') {
        const randomIndex = Math.floor(Math.random() * filteredSongs.length);
        selectedSong = filteredSongs[randomIndex];
      } else {
        // Selecci√≥n secuencial
        if (this.currentSongIndex >= filteredSongs.length) {
          this.currentSongIndex = 0;
        }
        selectedSong = filteredSongs[this.currentSongIndex];
      }
      
      console.log('‚úÖ Canci√≥n de interrupci√≥n seleccionada:', {
        playlist: playlist.nombre,
        songTitle: selectedSong?.canciones?.titulo || selectedSong?.titulo,
        songArtist: selectedSong?.canciones?.artista || selectedSong?.artista
      });
      
      return selectedSong;
      
    } catch (error) {
      console.error('‚ùå Error seleccionando canci√≥n de playlist agendada:', error);
      return null;
    }
  }

  /**
   * Verificaci√≥n peri√≥dica de scheduling
   */
  async checkScheduling() {
    // No hacer nada si estamos en estado de error
    if (this.isInErrorState) return;
    
    // Protecci√≥n: no ejecutar si hay selecci√≥n de canci√≥n en curso
    if (this.isHandlingSongEnd) {
      console.log('‚è∏Ô∏è Verificaci√≥n de scheduling pospuesta - selecci√≥n de canci√≥n en curso');
      return;
    }
    try {
      console.log('üïê Verificaci√≥n de scheduling autom√°tica');
      // üîß NUEVO: Limpiar playlists ejecutadas si cambi√≥ de d√≠a
      this.cleanupExecutedPlaylists();
      // üîß NUEVO: Recargar playlists del canal para detectar cambios
      if (this.currentChannel) {
        console.log('üîÑ Recargando playlists del canal para detectar cambios...');
        await this.loadChannelPlaylists();
        // Log de estad√≠sticas actualizadas
        console.log('üìä Playlists actualizadas:', {
          rotacion: this.rotationPlaylists.length,
          intervalo: this.intervalPlaylists.length,
          agendada: this.scheduledPlaylists.length
        });
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error en verificaci√≥n de scheduling:', error);
    }
  }

  /**
   * Limpiar playlists ejecutadas cuando cambie de d√≠a
   */
  cleanupExecutedPlaylists() {
    const today = new Date().toISOString().split('T')[0];
    const currentKeys = Array.from(this.executedScheduledPlaylists);
    
    for (const key of currentKeys) {
      const keyDate = key.split('_')[1]; // Obtener fecha del key
      if (keyDate !== today) {
        this.executedScheduledPlaylists.delete(key);
        console.log('üßπ Limpiando playlist ejecutada de otro d√≠a:', key);
      }
    }
  }

  /**
   * Detener bucle infinito de errores
   */
  stopErrorLoop() {
    console.log('üõë Deteniendo bucle de errores');
    this.isActive = false;
    this.stopTimers();
    
    // Mostrar mensaje al usuario
    console.warn('üö´ AutoDJ pausado debido a errores. Haz clic en el bot√≥n de reproducci√≥n para continuar.');
  }

  /**
   * Resetear estado de error
   */
  resetErrorState() {
    console.log('üîÑ Reseteando estado de error');
    this.errorCount = 0;
    this.lastErrorTime = 0;
    this.isInErrorState = false;
    // No resetear requiresUserInteraction aqu√≠ - debe hacerse manualmente
  }

  /**
   * Permitir reproducci√≥n despu√©s de interacci√≥n del usuario
   */
  allowPlaybackAfterInteraction() {
    console.log('üéØ Interacci√≥n del usuario recibida - permitiendo reproducci√≥n');
    this.requiresUserInteraction = false;
    this.resetErrorState();
  }

  /**
   * Obtener estado actual del AutoDJ
   */
  getState() {
    const audioState = audioPlayer.getState();
    
    return {
      // Estado general
      isActive: this.isActive,
      currentChannel: this.currentChannel,
      
      // Estado de reproducci√≥n
      currentPlaylist: this.currentPlaylist,
      currentSong: this.currentSong,
      isPlaying: audioState.isPlaying,
      
      // Contadores
      globalRotationCounter: this.globalRotationCounter,
      
      // Estado de interrupciones
      isInInterrupt: this.isInInterrupt,
      interruptType: this.interruptType,
      
      // Estado de errores
      isInErrorState: this.isInErrorState,
      requiresUserInteraction: this.requiresUserInteraction,
      errorCount: this.errorCount,
      
      // üîß SISTEMA H√çBRIDO: Control de precarga inteligente
      userHasStartedPlaying: this.userHasStartedPlaying,
      smartPreloadEnabled: this.smartPreloadEnabled,
      
      // Estad√≠sticas de playlists
      playlistsLoaded: {
        rotacion: this.rotationPlaylists.length,
        intervalo: this.intervalPlaylists.length,
        agendada: this.scheduledPlaylists.length
      },
      
      // Estado del reproductor
      audioState: audioState
    };
  }

  /**
   * Destruir servicio y limpiar recursos
   */
  destroy() {
    console.log('üóëÔ∏è Destruyendo AutoDJ Service');
    
    this.stop();
    this.clearAudioEvents();
    this.cleanupRealtimeSubscriptions();
    this.resetState();
  }
}

// Exportar singleton
const autoDj = new AutoDjService();
export default autoDj; 