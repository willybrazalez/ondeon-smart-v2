/**
 * AudioPlayerService - Gestiona la reproducci√≥n real de audio con crossfade
 * 
 * Sistema de doble reproductor para transiciones suaves:
 * - Player A y Player B se alternan
 * - Crossfade autom√°tico al final de cada canci√≥n
 * - Nunca se detiene la reproducci√≥n
 */

// üîß CONFIGURACI√ìN GLOBAL - Para debuggear problemas de crossfade
const CROSSFADE_ENABLED = false; // ‚ö†Ô∏è Desactivado temporalmente para testing
const INTERRUPTION_CROSSFADE_ENABLED = true; // ‚úÖ Crossfade espec√≠fico para interrupciones agendadas

class AudioPlayerService {
  constructor() {
    // Reproductores alternados para crossfade
    this.playerA = null;
    this.playerB = null;
    this.currentPlayer = 'A'; // 'A' o 'B'
    
    // Control de volumen
    this.masterVolume = 0.8;
    this.musicVolume = 0.8;
    this.contentVolume = 1.0;
    
    // Reproductor de contenidos activo
    this.activeContentPlayer = null;
    
    // Estado de reproducci√≥n
    this.isPlaying = false;
    this.isPaused = false;
    this.currentSong = null;
    this.nextSong = null;
    
    // Canal actual para verificaciones
    this.currentChannelId = null;
    
    // Configuraci√≥n de crossfade
    this.crossfadeDuration = 3000; // 3 segundos
    this.interruptionCrossfadeDuration = 6000; // 6 segundos para interrupciones agendadas
    this.crossfadeStartThreshold = 5; // Iniciar crossfade 5 segundos antes del final
    this.isCrossfading = false;
    this.isInterruptionCrossfade = false; // üîß NUEVO: Flag para crossfade de interrupci√≥n
    this.isInterruptionActive = false; // üîß NUEVO: Flag para interrupci√≥n activa
    
    // Estados de carga
    this.isLoading = false;
    this.nextSongLoaded = false;
    
    // üîß NUEVO: Flag para evitar doble emisi√≥n de onEnd
    this.endEventEmitted = false;
    
    // üîß NUEVO: Flag para evitar logs infinitos de crossfade
    this.crossfadeLogShown = false;
    
    // Eventos
    this.eventListeners = {
      onPlay: [],
      onPause: [],
      onEnd: [],
      onError: [],
      onTimeUpdate: [],
      onLoadStart: [],
      onLoadEnd: [],
      onSongChange: [],
      onRequestPreload: [], // Nuevo evento para solicitar precarga
      onInterruptionStart: [], // üîß NUEVO: Evento para inicio de interrupci√≥n
      onInterruptionEnd: [], // üîß NUEVO: Evento para fin de interrupci√≥n
    };

    // Throttling para eventos
    this.lastEndEvent = 0;
    this.endEventThrottle = 1000; // üîß REDUCIDO: De 2000ms a 1000ms para ser menos restrictivo

    // Watchdog para detectar paradas inesperadas
    this.watchdogInterval = null;
    this.lastProgressTime = 0;
    this.lastCrossfadeTime = 0; // üîß NUEVO: Timestamp del √∫ltimo crossfade
    
    // üîß NUEVO: Configuraci√≥n de debug para watchdog
    this.watchdogDebugMode = false; // Cambiar a true para ver logs detallados

    // Solo mostrar logs de inicializaci√≥n si hay un usuario autenticado
    // El log se mostrar√° cuando se acceda por primera vez a trav√©s del proxy lazy
    // this.startWatchdog(); // Movido a inicializaci√≥n lazy
  }

  /**
   * Obtener el reproductor activo actual
   */
  getActivePlayer() {
    return this.currentPlayer === 'A' ? this.playerA : this.playerB;
  }

  /**
   * Obtener el reproductor inactivo (para precargar siguiente canci√≥n)
   */
  getInactivePlayer() {
    return this.currentPlayer === 'A' ? this.playerB : this.playerA;
  }

  /**
   * Cargar y preparar una canci√≥n para reproducci√≥n
   */
  async loadSong(song, preloadNext = false) {
    try {
      const songTitle = song?.canciones?.titulo || song?.titulo || 'Sin t√≠tulo';
      console.log(`üéµ ${preloadNext ? 'Precargando siguiente' : 'Cargando'} canci√≥n:`, songTitle);
      
      if (!song?.canciones?.url_s3 && !song?.url_s3) {
        throw new Error(`No se encontr√≥ URL de audio para: ${songTitle}`);
      }

      // ‚úÖ NUEVO MODELO: Las canciones son globales, no verificar canal_id
      console.log('‚úÖ Cargando canci√≥n global:', songTitle);

      if (!preloadNext) {
        this.isLoading = true;
        this.emit('onLoadStart', song);
      }
      
      // Crear nuevo elemento de audio
      const audio = new Audio();
      const audioUrl = song?.canciones?.url_s3 || song?.url_s3;
      
      // Configurar CORS y propiedades
      audio.crossOrigin = 'anonymous';
      audio.preload = 'auto';
      audio.volume = 0; // Empezar en silencio
      
      // Configurar eventos
      this.setupAudioEvents(audio, song, preloadNext);
      
      // Establecer URL
      audio.src = audioUrl;
      
      // Esperar a que est√© listo
      await this.waitForCanPlay(audio);
      
      // üîß L√ìGICA SIMPLIFICADA sin crossfade
      if (!CROSSFADE_ENABLED) {
        if (preloadNext) {
          console.log('üö´ Precarga ignorada - crossfade desactivado');
          return true; // Simular √©xito para no romper el flujo
        }
        
        // Solo usar playerA para reproducci√≥n simple
        if (this.playerA) {
          this.cleanupPlayer(this.playerA);
        }
        
        this.playerA = audio;
        this.currentPlayer = 'A';
        this.currentSong = song;
        this.isLoading = false;
        // üîß NUEVO: Resetear flags para nueva canci√≥n
        this.endEventEmitted = false;
        this.crossfadeLogShown = false;
        this.emit('onLoadEnd', song);
        console.log('üéµ Canci√≥n cargada en reproductor √∫nico (sin crossfade):', songTitle);
        
      } else {
        // üîß L√ìGICA ORIGINAL con crossfade
        if (preloadNext) {
          // Asignar como siguiente canci√≥n
          this.nextSong = song;
          const inactivePlayer = this.getInactivePlayer();
          if (inactivePlayer) {
            this.cleanupPlayer(inactivePlayer);
          }
          
          if (this.currentPlayer === 'A') {
            this.playerB = audio;
          } else {
            this.playerA = audio;
          }
          
          this.nextSongLoaded = true;
          console.log('üéµ Siguiente canci√≥n precargada:', songTitle);
        } else {
          // Configurar como canci√≥n actual
          const activePlayer = this.getActivePlayer();
          if (activePlayer) {
            this.cleanupPlayer(activePlayer);
          }
          
          if (this.currentPlayer === 'A') {
            this.playerA = audio;
          } else {
            this.playerB = audio;
          }
          
          this.currentSong = song;
          this.isLoading = false;
          // üîß NUEVO: Resetear flags para nueva canci√≥n
          this.endEventEmitted = false;
          this.crossfadeLogShown = false;
          this.emit('onLoadEnd', song);
          console.log('üéµ Canci√≥n cargada como actual:', songTitle);
        }
      }
      
      return true;
    } catch (error) {
      console.error('‚ùå Error cargando canci√≥n:', error);
      this.isLoading = false;
      this.emit('onError', error);
      return false;
    }
  }

  /**
   * Configurar eventos de audio con manejo mejorado
   */
  setupAudioEvents(audio, song, isPreload = false) {
    const songTitle = song?.canciones?.titulo || song?.titulo || 'Sin t√≠tulo';
    
    const onTimeUpdate = () => {
      const isCurrentlyActive = this.getActivePlayer() === audio;
      
      // Actualizar progreso siempre que haya reproducci√≥n (incluso durante crossfade)
      if (!isPreload && (isCurrentlyActive || this.isCrossfading)) {
        const currentTime = audio.currentTime;
        const duration = audio.duration;
        
        // Actualizar tiempo para watchdog - IMPORTANTE durante crossfade
        this.lastProgressTime = Date.now();
        
        // Solo emitir eventos del reproductor principal
        if (isCurrentlyActive) {
          this.emit('onTimeUpdate', {
            currentTime,
            duration,
            progress: duration > 0 ? (currentTime / duration) * 100 : 0
          });
        }

        // Verificar si debe iniciar crossfade (solo del reproductor principal)
        if (isCurrentlyActive) {
          this.checkForCrossfade(audio);
          
          // üîß NUEVO: Verificar si la canci√≥n termin√≥ en onTimeUpdate
          if (currentTime >= duration - 0.1 && duration > 0) {
            console.log('üîö Canci√≥n terminada detectada en onTimeUpdate - emitiendo onEnd');
            this.emit('onEnd', song);
          }
        }
      }
    };

    const onEnded = () => {
      console.log('üîö Canci√≥n terminada:', songTitle, {
        isPreload,
        isActivePlayer: this.getActivePlayer() === audio,
        isCrossfading: this.isCrossfading,
        currentTime: audio.currentTime,
        duration: audio.duration,
        progress: audio.duration > 0 ? (audio.currentTime / audio.duration) * 100 : 0
      });
      
      // üîß MEJORADO: Throttling m√°s inteligente
      const now = Date.now();
      if (now - this.lastEndEvent < this.endEventThrottle) {
        console.log('‚ö†Ô∏è Evento onEnded throttled - muy reciente');
        return;
      }
      
      // üîß NUEVO: Verificar si realmente termin√≥ la canci√≥n
      if (audio.currentTime < audio.duration - 1) {
        console.log('‚ö†Ô∏è Evento onEnded ignorado - canci√≥n no termin√≥ realmente');
        return;
      }
      
      this.lastEndEvent = now;

      // Solo emitir si es el reproductor activo y no estamos en crossfade
      if (!isPreload && this.getActivePlayer() === audio && !this.isCrossfading) {
        console.log('‚úÖ Emitiendo evento onEnd para AutoDJ');
        this.emit('onEnd', song);
      } else {
        console.log('‚ö†Ô∏è No emitiendo onEnd:', {
          isPreload,
          isActivePlayer: this.getActivePlayer() === audio,
          isCrossfading: this.isCrossfading
        });
      }
    };

    const onError = (e) => {
      const error = e.target.error;
      let errorMessage = 'Error desconocido';
      let errorCode = 0;
      
      if (error) {
        errorCode = error.code;
        switch (error.code) {
          case 1:
            errorMessage = 'MEDIA_ERR_ABORTED: La reproducci√≥n fue abortada';
            break;
          case 2:
            errorMessage = 'MEDIA_ERR_NETWORK: Error de red';
            break;
          case 3:
            errorMessage = 'MEDIA_ERR_DECODE: Error de decodificaci√≥n';
            break;
          case 4:
            errorMessage = 'MEDIA_ERR_SRC_NOT_SUPPORTED: Formato no soportado o archivo corrupto';
            break;
          default:
            errorMessage = error.message || 'Error de audio desconocido';
        }
      }
      
      console.error(`‚ùå Error en audio (${songTitle}):`, {
        code: errorCode,
        message: errorMessage,
        error: error
      });
      
      if (!isPreload && this.getActivePlayer() === audio) {
        this.emit('onError', {
          error: new Error(`Error cargando audio: ${errorMessage}`),
          song: song,
          errorCode,
          errorMessage,
          songTitle,
          originalError: error
        });
      }
    };

    const onPlay = () => {
      if (!isPreload && this.getActivePlayer() === audio) {
        this.isPlaying = true;
        this.isPaused = false;
        this.emit('onPlay', song);
      }
    };

    const onPause = () => {
      if (!isPreload && this.getActivePlayer() === audio) {
        this.isPlaying = false;
        this.isPaused = true;
        this.emit('onPause', song);
      }
    };

    // Agregar eventos
    audio.addEventListener('timeupdate', onTimeUpdate);
    audio.addEventListener('ended', onEnded);
    audio.addEventListener('error', onError);
    audio.addEventListener('play', onPlay);
    audio.addEventListener('pause', onPause);

    // Guardar referencias para cleanup
    audio._eventHandlers = {
      timeupdate: onTimeUpdate,
      ended: onEnded,
      error: onError,
      play: onPlay,
      pause: onPause
    };
  }

  /**
   * Verificar si debe iniciar crossfade
   */
  checkForCrossfade(audio) {
    if (this.isCrossfading) {
      return;
    }

    const timeRemaining = audio.duration - audio.currentTime;
    const progress = (audio.currentTime / audio.duration) * 100;
    
    // Debug detallado
    if (timeRemaining <= 10 && timeRemaining > 8) {
      console.log(`üìä Audio estado:`, {
        currentTime: audio.currentTime.toFixed(1),
        duration: audio.duration.toFixed(1),
        timeRemaining: timeRemaining.toFixed(1),
        progress: progress.toFixed(1) + '%',
        nextSongLoaded: this.nextSongLoaded,
        isCrossfading: this.isCrossfading,
        activePlayer: this.currentPlayer,
        crossfadeEnabled: CROSSFADE_ENABLED
      });
    }
    
    // üîß SISTEMA H√çBRIDO: Precarga JUST-IN-TIME m√°s agresiva (20 segundos)
    if (timeRemaining <= 20 && timeRemaining > 19 && !this.nextSongLoaded) {
      console.log('üîÑ JUST-IN-TIME: Solicitando precarga (quedan ~20 segundos)');
      this.emit('onRequestPreload');
    }
    
    // üö´ Si crossfade est√° DESACTIVADO, usar transici√≥n simple
    if (!CROSSFADE_ENABLED) {
      // üîß CORREGIDO: Solo mostrar log una vez cuando quedan pocos segundos
      if (timeRemaining <= 5 && timeRemaining > 4.5 && !this.crossfadeLogShown) {
        console.log('üîö SIN CROSSFADE: Esperando finalizaci√≥n natural de la canci√≥n (quedan', timeRemaining.toFixed(1), 's)');
        this.crossfadeLogShown = true;
      }
      return;
    }
    
    // ‚úÖ CROSSFADE ACTIVADO - L√≥gica original
    if (!this.nextSongLoaded) {
      if (timeRemaining <= 10) {
        console.warn('‚ö†Ô∏è Siguiente canci√≥n no est√° precargada, quedan:', timeRemaining.toFixed(1) + 's');
      }
      return;
    }

    // Iniciar crossfade cuando quedan X segundos
    if (timeRemaining <= this.crossfadeStartThreshold && timeRemaining > 0) {
      console.log(`üîÑ Iniciando crossfade (quedan ${timeRemaining.toFixed(1)}s, progreso: ${progress.toFixed(1)}%)`);
      this.startCrossfade();
    }
  }

  /**
   * Iniciar crossfade entre reproductores (m√©todo p√∫blico)
   */
  async startCrossfade() {
    if (this.isCrossfading) {
      console.warn('‚ö†Ô∏è Crossfade ya en progreso, ignorando');
      return false;
    }
    
    if (!this.nextSongLoaded) {
      console.error('‚ùå No hay siguiente canci√≥n precargada para crossfade');
      // Emitir evento onEnd para que AutoDJ maneje la transici√≥n manualmente
      this.emit('onEnd', this.currentSong);
      return false;
    }

    // VERIFICACI√ìN CR√çTICA: Bloquear canciones de canales incorrectos
    if (this.nextSong && this.nextSong.canciones) {
      const nextSongChannelId = this.nextSong.canciones.canal_id;
      const nextSongTitle = this.nextSong.canciones.titulo;
      
      // Necesitamos el canal actual - lo obtenemos del emisor de eventos
      const currentChannelId = this.getCurrentChannelId();
      
      if (currentChannelId && nextSongChannelId !== currentChannelId) {
        console.error('üö´ BLOQUEANDO CROSSFADE - Canci√≥n de canal incorrecto:', {
          nextSongTitle,
          nextSongChannelId,
          currentChannelId,
          action: 'Emitiendo onEnd para nueva selecci√≥n'
        });
        
        // Limpiar la canci√≥n incorrecta
        this.nextSong = null;
        this.nextSongLoaded = false;
        
        // Forzar nueva selecci√≥n
        this.emit('onEnd', this.currentSong);
        return false;
      } else {
        console.log('‚úÖ Crossfade autorizado - canci√≥n del canal correcto:', {
          nextSongTitle,
          channelId: nextSongChannelId
        });
      }
    }

    console.log('üé≠ INICIANDO CROSSFADE - Pausando watchdog');
    this.isCrossfading = true;
    const currentPlayer = this.getActivePlayer();
    const nextPlayer = this.getInactivePlayer();

    console.log('üîÑ Ejecutando crossfade:', {
      currentPlayer: this.currentPlayer,
      currentSong: this.currentSong?.canciones?.titulo || 'Sin t√≠tulo',
      nextSong: this.nextSong?.canciones?.titulo || 'Sin t√≠tulo',
      playerA: !!this.playerA,
      playerB: !!this.playerB,
      watchdogPaused: this.isCrossfading
    });

    if (!currentPlayer || !nextPlayer) {
      console.error('‚ùå No se pueden obtener reproductores para crossfade:', {
        currentPlayer: !!currentPlayer,
        nextPlayer: !!nextPlayer,
        activePlayer: this.currentPlayer
      });
      this.isCrossfading = false;
      // Fallback: emitir onEnd para transici√≥n manual
      this.emit('onEnd', this.currentSong);
      return false;
    }

          try {
        // Timeout de seguridad para crossfade
        const crossfadeTimeout = setTimeout(() => {
          console.error('‚è∞ Timeout de crossfade - forzando finalizaci√≥n');
          this.isCrossfading = false;
          this.emit('onEnd', this.currentSong);
        }, this.crossfadeDuration + 5000); // 5 segundos extra de margen

        // Configurar vol√∫menes iniciales
        const currentInitialVolume = this.calculateVolume(this.currentSong);
        const nextFinalVolume = this.calculateVolume(this.nextSong);
        
        console.log('üéöÔ∏è Configurando vol√∫menes crossfade:', {
          currentInitialVolume,
          nextFinalVolume
        });
        
        nextPlayer.volume = 0;
        currentPlayer.volume = currentInitialVolume;

        // Iniciar reproducci√≥n del siguiente reproductor
        console.log('‚ñ∂Ô∏è Iniciando reproductor siguiente');
        await nextPlayer.play();

        // Realizar crossfade gradual
        const fadeSteps = 60; // M√°s pasos para suavidad
        const stepDuration = this.crossfadeDuration / fadeSteps;

        console.log('üîÑ Iniciando fade gradual:', { fadeSteps, stepDuration });

        for (let i = 0; i <= fadeSteps; i++) {
          const progress = i / fadeSteps;
          
          // Verificar que los reproductores siguen v√°lidos
          if (!currentPlayer || !nextPlayer) {
            throw new Error('Reproductores se volvieron nulos durante crossfade');
          }
          
          // Verificar que no se haya cancelado el crossfade
          if (!this.isCrossfading) {
            console.warn('‚ö†Ô∏è Crossfade cancelado durante ejecuci√≥n');
            break;
          }
          
          // Fade out actual
          currentPlayer.volume = currentInitialVolume * (1 - progress);
          
          // Fade in siguiente
          nextPlayer.volume = nextFinalVolume * progress;
          
          await new Promise(resolve => setTimeout(resolve, stepDuration));
        }

        // Limpiar timeout si llegamos aqu√≠ exitosamente
        clearTimeout(crossfadeTimeout);

        // Solo finalizar si seguimos en crossfade
        if (this.isCrossfading) {
          console.log('‚úÖ Finalizando crossfade');
          this.completeCrossfade();
          return true;
        } else {
          console.warn('‚ö†Ô∏è Crossfade interrumpido, no finalizando');
          return false;
        }

      } catch (error) {
        console.error('‚ùå Error durante crossfade:', error);
        this.isCrossfading = false;
        
        // Fallback cr√≠tico: si crossfade falla, emitir onEnd para continuar reproducci√≥n
        console.log('üîÑ Fallback: emitiendo onEnd por error en crossfade');
        this.emit('onEnd', this.currentSong);
        return false;
      }
  }

  /**
   * Completar crossfade y cambiar reproductor activo
   */
  completeCrossfade() {
    const currentPlayer = this.getActivePlayer();
    
    console.log('üé≠ COMPLETANDO CROSSFADE - Reactivando watchdog');
    
    // Pausar y limpiar reproductor anterior
    if (currentPlayer) {
      currentPlayer.pause();
      this.cleanupPlayer(currentPlayer);
    }

    // Cambiar reproductor activo
    const previousPlayer = this.currentPlayer;
    this.currentPlayer = this.currentPlayer === 'A' ? 'B' : 'A';
    this.currentSong = this.nextSong;
    this.nextSong = null;
    this.nextSongLoaded = false;
    this.isCrossfading = false; // IMPORTANTE: Reactivar watchdog

    console.log('‚úÖ Crossfade completado:', {
      previousPlayer,
      newActivePlayer: this.currentPlayer,
      newSong: this.currentSong?.canciones?.titulo || this.currentSong?.titulo || 'Sin t√≠tulo',
      watchdogReactivated: !this.isCrossfading
    });
    
    // Actualizar progreso inmediatamente para watchdog
    this.lastProgressTime = Date.now();
    
    // Emitir evento de cambio de canci√≥n
    this.emit('onSongChange', this.currentSong);
  }

  /**
   * üîß NUEVO: Iniciar crossfade de interrupci√≥n agendada
   * M√©todo espec√≠fico para interrupciones de playlists agendadas
   */
  async startInterruptionCrossfade(interruptionSong) {
    if (!INTERRUPTION_CROSSFADE_ENABLED) {
      console.log('üö´ Crossfade de interrupci√≥n desactivado - reproducci√≥n directa');
      return await this.loadAndPlayInterruption(interruptionSong);
    }

    // üîß ELIMINADO: Verificaci√≥n que causaba fallo en crossfade
    // Permitir interrupciones incluso si hay crossfade en progreso

    console.log('üé≠ INICIANDO CROSSFADE DE INTERRUPCI√ìN AGENDADA');
    this.isCrossfading = true;
    this.isInterruptionCrossfade = true;
    this.isInterruptionActive = true; // üîß NUEVO: Activar flag de interrupci√≥n

    try {
      // Emitir evento de inicio de interrupci√≥n
      this.emit('onInterruptionStart', {
        currentSong: this.currentSong,
        interruptionSong: interruptionSong
      });

      // Cargar canci√≥n de interrupci√≥n en el reproductor inactivo
      const inactivePlayer = this.getInactivePlayer();
      if (inactivePlayer) {
        this.cleanupPlayer(inactivePlayer);
      }

      const audio = new Audio();
      audio.crossOrigin = 'anonymous';
      audio.preload = 'auto';
      audio.volume = 0; // Empezar en silencio

      // Configurar eventos b√°sicos para la canci√≥n de interrupci√≥n
      audio.addEventListener('canplaythrough', () => {
        console.log('‚úÖ Canci√≥n de interrupci√≥n lista para reproducir');
      });

      audio.addEventListener('error', (e) => {
        console.error('‚ùå Error cargando canci√≥n de interrupci√≥n:', e);
        this.isCrossfading = false;
        this.isInterruptionCrossfade = false;
        this.isInterruptionActive = false; // üîß NUEVO: Desactivar flag de interrupci√≥n
      });

      const audioUrl = interruptionSong?.canciones?.url_s3 || interruptionSong?.url_s3;
      audio.src = audioUrl;

      // Esperar a que est√© listo
      await this.waitForCanPlay(audio);

      // Asignar al reproductor inactivo
      if (this.currentPlayer === 'A') {
        this.playerB = audio;
      } else {
        this.playerA = audio;
      }

      const currentPlayer = this.getActivePlayer();
      const nextPlayer = this.getInactivePlayer();

      if (!currentPlayer || !nextPlayer) {
        throw new Error('No se pueden obtener reproductores para crossfade de interrupci√≥n');
      }

      // Configurar vol√∫menes iniciales
      const currentInitialVolume = this.calculateVolume(this.currentSong);
      const nextFinalVolume = this.calculateVolume(interruptionSong);

      console.log('üéöÔ∏è Configurando vol√∫menes crossfade de interrupci√≥n:', {
        currentInitialVolume,
        nextFinalVolume,
        duration: this.interruptionCrossfadeDuration
      });

      nextPlayer.volume = 0;
      currentPlayer.volume = currentInitialVolume;

      // Iniciar reproducci√≥n del reproductor de interrupci√≥n
      console.log('‚ñ∂Ô∏è Iniciando reproductor de interrupci√≥n');
      await nextPlayer.play();

      // Realizar crossfade gradual m√°s largo para interrupciones
      const fadeSteps = 120; // M√°s pasos para mayor suavidad
      const stepDuration = this.interruptionCrossfadeDuration / fadeSteps;

      console.log('üîÑ Iniciando fade gradual de interrupci√≥n:', { fadeSteps, stepDuration });

      for (let i = 0; i <= fadeSteps; i++) {
        const progress = i / fadeSteps;

        // Verificar que los reproductores siguen v√°lidos
        if (!currentPlayer || !nextPlayer) {
          throw new Error('Reproductores se volvieron nulos durante crossfade de interrupci√≥n');
        }

        // Verificar que no se haya cancelado el crossfade
        if (!this.isCrossfading) {
          console.warn('‚ö†Ô∏è Crossfade de interrupci√≥n cancelado durante ejecuci√≥n');
          break;
        }

        // Fade out actual
        currentPlayer.volume = currentInitialVolume * (1 - progress);

        // Fade in interrupci√≥n
        nextPlayer.volume = nextFinalVolume * progress;

        await new Promise(resolve => setTimeout(resolve, stepDuration));
      }

      // Completar crossfade de interrupci√≥n
      if (this.isCrossfading) {
        console.log('‚úÖ Finalizando crossfade de interrupci√≥n');
        this.completeInterruptionCrossfade(interruptionSong);
        return true;
      } else {
        console.warn('‚ö†Ô∏è Crossfade de interrupci√≥n interrumpido');
        return false;
      }

    } catch (error) {
      console.error('‚ùå Error durante crossfade de interrupci√≥n:', error);
      this.isCrossfading = false;
      this.isInterruptionCrossfade = false;
      this.isInterruptionActive = false; // üîß NUEVO: Desactivar flag de interrupci√≥n
      
      // Fallback: cargar interrupci√≥n directamente
      console.log('üîÑ Fallback: cargando interrupci√≥n directamente');
      return await this.loadAndPlayInterruption(interruptionSong);
    }
  }

  /**
   * üîß NUEVO: Completar crossfade de interrupci√≥n
   */
  completeInterruptionCrossfade(interruptionSong) {
    const currentPlayer = this.getActivePlayer();

    console.log('üé≠ COMPLETANDO CROSSFADE DE INTERRUPCI√ìN - Reactivando watchdog');

    // Pausar y limpiar reproductor anterior
    if (currentPlayer) {
      currentPlayer.pause();
      this.cleanupPlayer(currentPlayer);
    }

    // Cambiar reproductor activo
    const previousPlayer = this.currentPlayer;
    this.currentPlayer = this.currentPlayer === 'A' ? 'B' : 'A';
    this.currentSong = interruptionSong;
    this.isCrossfading = false;
    this.isInterruptionCrossfade = false;
    this.isInterruptionActive = false; // üîß NUEVO: Desactivar flag de interrupci√≥n

    console.log('‚úÖ Crossfade de interrupci√≥n completado:', {
      previousPlayer,
      newActivePlayer: this.currentPlayer,
      newSong: this.currentSong?.canciones?.titulo || this.currentSong?.titulo || 'Sin t√≠tulo',
      watchdogReactivated: !this.isCrossfading
    });

    // üîß MEJORADO: Resetear watchdog para nueva canci√≥n
    this.lastProgressTime = Date.now();
    this.lastCrossfadeTime = Date.now(); // üîß NUEVO: Actualizar timestamp del crossfade
    
    // üîß NUEVO: Resetear completamente el estado del watchdog
    setTimeout(() => {
      // Forzar actualizaci√≥n del progreso despu√©s de un breve delay
      const activePlayer = this.getActivePlayer();
      if (activePlayer && !activePlayer.paused) {
        this.lastProgressTime = Date.now();
        console.log('üîÑ Watchdog reseteado para nueva canci√≥n despu√©s de crossfade');
        
        // üîß CR√çTICO: Verificar que el watchdog est√© monitoreando la canci√≥n correcta
        console.log('üîç Verificaci√≥n watchdog post-crossfade:', {
          currentSong: this.currentSong?.canciones?.titulo || this.currentSong?.titulo,
          activePlayerCurrentTime: activePlayer.currentTime,
          activePlayerDuration: activePlayer.duration,
          lastProgressTime: this.lastProgressTime
        });
      }
    }, 2000); // Aumentado a 2 segundos para dar m√°s tiempo

    // Emitir eventos
    this.emit('onSongChange', this.currentSong);
    this.emit('onInterruptionEnd', {
      previousSong: this.currentSong,
      currentSong: this.currentSong
    });
  }

  /**
   * üîß NUEVO: Cargar y reproducir interrupci√≥n directamente (fallback)
   */
  async loadAndPlayInterruption(interruptionSong) {
    console.log('üéµ Cargando interrupci√≥n directamente (sin crossfade)');
    
    try {
      const success = await this.loadSong(interruptionSong, false);
      if (success) {
        this.currentSong = interruptionSong;
        await this.play();
        
        // Emitir eventos de interrupci√≥n
        this.emit('onInterruptionStart', {
          currentSong: this.currentSong,
          interruptionSong: interruptionSong
        });
        this.emit('onInterruptionEnd', {
          previousSong: this.currentSong,
          currentSong: this.currentSong
        });
        
        return true;
      }
      return false;
    } catch (error) {
      console.error('‚ùå Error cargando interrupci√≥n directamente:', error);
      return false;
    }
  }

  /**
   * Precargar siguiente canci√≥n para crossfade
   */
  async preloadNextSong(song) {
    if (!song) return false;
    
    // üö´ Si crossfade est√° DESACTIVADO, no precargar
    if (!CROSSFADE_ENABLED) {
      console.log('üö´ Precarga saltada - crossfade desactivado');
      return false;
    }
    
    // ‚úÖ NUEVO MODELO: Las canciones son globales, no verificar canal_id
    const songTitle = song?.canciones?.titulo || song?.titulo || 'Sin t√≠tulo';
    console.log('‚úÖ Precargando canci√≥n global:', songTitle);
    
    return await this.loadSong(song, true);
  }

  /**
   * Esperar a que el audio est√© listo para reproducir
   */
  waitForCanPlay(audio) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Timeout cargando audio'));
      }, 15000);

      const onCanPlay = () => {
        clearTimeout(timeout);
        audio.removeEventListener('canplaythrough', onCanPlay);
        audio.removeEventListener('error', onError);
        resolve();
      };

      const onError = (e) => {
        clearTimeout(timeout);
        audio.removeEventListener('canplaythrough', onCanPlay);
        audio.removeEventListener('error', onError);
        reject(new Error(`Error cargando audio: ${e.message}`));
      };

      audio.addEventListener('canplaythrough', onCanPlay);
      audio.addEventListener('error', onError);
    });
  }

  /**
   * Reproducir audio actual
   */
  async play() {
    let activePlayer;
    
    // üîß L√ìGICA SIMPLIFICADA sin crossfade
    if (!CROSSFADE_ENABLED) {
      activePlayer = this.playerA;
      if (!activePlayer) {
        console.error('‚ùå No hay reproductor √∫nico para reproducir');
        return false;
      }
    } else {
      // üîß L√ìGICA ORIGINAL con crossfade
      activePlayer = this.getActivePlayer();
      if (!activePlayer) {
        console.error('‚ùå No hay reproductor activo para reproducir');
        return false;
      }
    }

    try {
      activePlayer.volume = this.calculateVolume(this.currentSong);
      await activePlayer.play();
      console.log('‚ñ∂Ô∏è Reproducci√≥n iniciada');
      return true;
    } catch (error) {
      console.error('‚ùå Error iniciando reproducci√≥n:', error);
      this.emit('onError', error);
      return false;
    }
  }

  /**
   * Pausar reproducci√≥n
   */
  pause() {
    let activePlayer;
    
    // üîß L√ìGICA SIMPLIFICADA sin crossfade
    if (!CROSSFADE_ENABLED) {
      activePlayer = this.playerA;
    } else {
      // üîß L√ìGICA ORIGINAL con crossfade
      activePlayer = this.getActivePlayer();
    }
    
    if (activePlayer) {
      activePlayer.pause();
      console.log('‚è∏Ô∏è Reproducci√≥n pausada');
    }
  }

  /**
   * Detener reproducci√≥n
   */
  stop() {
    this.pause();
    this.isPlaying = false;
    this.isPaused = false;
    console.log('‚èπÔ∏è Reproducci√≥n detenida');
  }

  /**
   * Cambiar a siguiente canci√≥n (usado si no hay crossfade)
   */
  async playNext(nextSong) {
    if (!nextSong) return false;
    
    console.log('‚è≠Ô∏è Cambiando a siguiente canci√≥n (sin crossfade)');
    
    // Si ya est√° precargada, hacer crossfade inmediato
    if (this.nextSongLoaded && this.nextSong) {
      await this.startCrossfade();
      return true;
    }
    
    // Si no, carga directa (fallback)
    const success = await this.loadSong(nextSong, false);
    if (success && this.isPlaying) {
      await this.play();
    }
    
    return success;
  }

  /**
   * Calcular volumen seg√∫n tipo de contenido
   */
  calculateVolume(song) {
    if (!song) return this.masterVolume;
    
    // Si es contenido publicitario, usar contentVolume
    if (song?.tipo === 'anuncio' || song?.canciones?.genero === 'anuncio') {
      return this.contentVolume * this.masterVolume;
    }
    
    // Para m√∫sica normal
    return this.musicVolume * this.masterVolume;
  }

  /**
   * Configurar volumen de m√∫sica
   */
  setMusicVolume(volume) {
    this.musicVolume = Math.max(0, Math.min(1, volume));
    
    // Aplicar a reproductor activo si est√° reproduciendo m√∫sica
    const activePlayer = this.getActivePlayer();
    if (activePlayer && this.currentSong?.tipo !== 'anuncio') {
      activePlayer.volume = this.calculateVolume(this.currentSong);
    }
    
    console.log('üéµ Volumen m√∫sica:', this.musicVolume);
  }

  /**
   * Configurar volumen de contenido
   */
  setContentVolume(volume) {
    this.contentVolume = Math.max(0, Math.min(1, volume));
    
    // Aplicar a reproductor activo si est√° reproduciendo anuncio
    const activePlayer = this.getActivePlayer();
    if (activePlayer && this.currentSong?.tipo === 'anuncio') {
      activePlayer.volume = this.calculateVolume(this.currentSong);
    }
    
    console.log('üì¢ Volumen contenido:', this.contentVolume);
  }

  /**
   * Configurar volumen maestro
   */
  setMasterVolume(volume) {
    this.masterVolume = Math.max(0, Math.min(1, volume));
    
    // Aplicar a todos los reproductores activos
    if (this.playerA && !this.isCrossfading) {
      this.playerA.volume = this.calculateVolume(this.currentSong);
    }
    if (this.playerB && !this.isCrossfading) {
      this.playerB.volume = this.calculateVolume(this.currentSong);
    }
    
    console.log('üîä Volumen maestro:', this.masterVolume);
  }

  /**
   * Obtener estado actual del reproductor
   */
  getState() {
    let activePlayer;
    
    // üîß L√ìGICA SIMPLIFICADA sin crossfade
    if (!CROSSFADE_ENABLED) {
      activePlayer = this.playerA;
    } else {
      // üîß L√ìGICA ORIGINAL con crossfade
      activePlayer = this.getActivePlayer();
    }
    
    return {
      isPlaying: this.isPlaying,
      isPaused: this.isPaused,
      isLoading: this.isLoading,
      isCrossfading: CROSSFADE_ENABLED ? this.isCrossfading : false,
      isInterruptionCrossfade: this.isInterruptionCrossfade,
      crossfadeEnabled: CROSSFADE_ENABLED,
      interruptionCrossfadeEnabled: INTERRUPTION_CROSSFADE_ENABLED,
      currentSong: this.currentSong,
      nextSong: CROSSFADE_ENABLED ? this.nextSong : null,
      nextSongLoaded: CROSSFADE_ENABLED ? this.nextSongLoaded : false,
      volume: this.masterVolume,
      musicVolume: this.musicVolume,
      contentVolume: this.contentVolume,
      currentTime: activePlayer?.currentTime || 0,
      duration: activePlayer?.duration || 0,
      activePlayer: CROSSFADE_ENABLED ? this.currentPlayer : 'A'
    };
  }

  /**
   * Funci√≥n de debug para monitorear estado detallado
   */
  debugState() {
    const activePlayer = this.getActivePlayer();
    const inactivePlayer = this.getInactivePlayer();
    
    console.log('üîç Debug AudioPlayer:', {
      // Estado general
      isPlaying: this.isPlaying,
      isPaused: this.isPaused,
      isLoading: this.isLoading,
      isCrossfading: this.isCrossfading,
      
      // Reproductores
      currentPlayer: this.currentPlayer,
      playerA_exists: !!this.playerA,
      playerB_exists: !!this.playerB,
      activePlayer_exists: !!activePlayer,
      inactivePlayer_exists: !!inactivePlayer,
      
      // Canciones
      currentSong: this.currentSong?.canciones?.titulo || 'Sin canci√≥n',
      nextSong: this.nextSong?.canciones?.titulo || 'Sin siguiente',
      nextSongLoaded: this.nextSongLoaded,
      
      // Timing
      currentTime: activePlayer?.currentTime?.toFixed(1) || 0,
      duration: activePlayer?.duration?.toFixed(1) || 0,
      timeRemaining: activePlayer?.duration ? (activePlayer.duration - activePlayer.currentTime).toFixed(1) : 0,
      progress: activePlayer?.duration ? ((activePlayer.currentTime / activePlayer.duration) * 100).toFixed(1) + '%' : '0%',
      
      // Estados de reproductores
      playerA_src: this.playerA?.src || 'Vac√≠o',
      playerB_src: this.playerB?.src || 'Vac√≠o',
      activePlayer_volume: activePlayer?.volume?.toFixed(2) || 0,
      inactivePlayer_volume: inactivePlayer?.volume?.toFixed(2) || 0
    });
    
    return this.getState();
  }

  /**
   * Watchdog para detectar paradas inesperadas de reproducci√≥n
   */
  startWatchdog() {
    // üîß CR√çTICO: DESACTIVAR COMPLETAMENTE el watchdog
    // console.log('üö´ Watchdog DESACTIVADO completamente');
    return;

    if (this.watchdogInterval) {
      clearInterval(this.watchdogInterval);
    }

    this.watchdogInterval = setInterval(() => {
      const activePlayer = this.getActivePlayer();
      
      // üîß MEJORADO: No verificar durante crossfade o interrupciones
      if (this.isCrossfading || this.isInterruptionCrossfade) {
        console.log('üîÑ Watchdog pausado durante crossfade/interrupci√≥n');
        return;
      }
      
      // üîß NUEVO: Protecci√≥n adicional despu√©s de interrupciones y crossfades
      const timeSinceInterruption = Date.now() - this.lastProgressTime;
      const timeSinceCrossfade = Date.now() - this.lastCrossfadeTime;
      
      // Per√≠odo de gracia m√°s largo despu√©s de crossfades (15 segundos)
      if (timeSinceCrossfade < 15000) {
        console.log('üîÑ Watchdog en per√≠odo de gracia despu√©s de crossfade');
        return;
      }
      
      // Per√≠odo de gracia est√°ndar despu√©s de interrupciones (10 segundos)
      if (timeSinceInterruption < 10000) {
        console.log('üîÑ Watchdog en per√≠odo de gracia despu√©s de interrupci√≥n');
        return;
      }
      
      // üîß ELIMINADO: Per√≠odo de gracia que no funciona
      // El watchdog se desactiva completamente durante interrupciones
      
      // üîß NUEVO: Desactivar watchdog completamente durante interrupciones agendadas
      if (this.isInterruptionCrossfade) {
        console.log('üîÑ Watchdog desactivado durante interrupci√≥n agendada');
        return; // No verificar nada durante interrupciones agendadas
      }
      
      // üîß NUEVO: Desactivar watchdog tambi√©n cuando hay interrupci√≥n activa
      if (this.isInterruptionActive) {
        console.log('üîÑ Watchdog desactivado - interrupci√≥n activa');
        return;
      }
      
      // üîß CR√çTICO: Desactivar watchdog durante crossfade de interrupci√≥n
      if (this.isInterruptionCrossfade) {
        console.log('üîÑ Watchdog desactivado - crossfade de interrupci√≥n activo');
        return;
      }
      
      // üîß MEJORADO: Solo verificar si hay un problema potencial
      const expectedSong = this.currentSong?.canciones?.titulo || this.currentSong?.titulo;
      if (!activePlayer || !expectedSong) {
        return; // No hay nada que verificar
      }
      
      // üîß NUEVO: Log de debug opcional
      if (this.watchdogDebugMode) {
        console.log('üîç Watchdog verificando:', {
          expectedSong,
          currentTime: activePlayer.currentTime,
          duration: activePlayer.duration,
          isPlaying: this.isPlaying
        });
      }
      
      if (this.isPlaying && activePlayer && !activePlayer.paused) {
        const currentTime = activePlayer.currentTime;
        const timeSinceLastProgress = Date.now() - this.lastProgressTime;
        
        // üîß MEJORADO: Solo verificar si hay un problema real (m√°s de 8 segundos sin progreso)
        if (timeSinceLastProgress > 8000 && this.lastProgressTime > 0) {
        
        // üîß NUEVO: Verificar si la canci√≥n termin√≥ antes de reportar problema
        if (activePlayer.currentTime >= activePlayer.duration - 0.5) {
          console.log('üîö Canci√≥n terminada detectada por watchdog - emitiendo onEnd');
          this.emit('onEnd', this.currentSong);
          return;
        }
        
        // üîß MEJORADO: Solo mostrar logs cuando hay un problema real
        console.warn('üö® Watchdog: Reproducci√≥n detenida inesperadamente');
        console.log('üìä Estado watchdog:', {
          expectedSong,
          isPlaying: this.isPlaying,
          isPaused: activePlayer.paused,
          currentTime: currentTime,
          timeSinceLastProgress,
          duration: activePlayer.duration,
          isCrossfading: this.isCrossfading,
          isInterruptionCrossfade: this.isInterruptionCrossfade
        });
          
                // üîß MEJORADO: Verificar si realmente est√° colgado antes de recovery
      if (activePlayer.readyState >= 3 && activePlayer.networkState === 1) {
        console.log('üîç Verificando si realmente est√° colgado...');
        // Solo hacer recovery si realmente est√° colgado
        this.attemptRecovery();
      } else {
        // üîß MEJORADO: Solo log si hay un problema real
        if (timeSinceLastProgress > 15000) { // Solo despu√©s de 15 segundos
          console.log('‚ÑπÔ∏è Audio en estado de carga, ignorando watchdog');
        }
        // Resetear el tiempo de progreso para dar m√°s tiempo
        this.lastProgressTime = Date.now();
      }
        }
      }
    }, 5000); // üîß MEJORADO: Verificar cada 5 segundos para reducir logs
  }

  /**
   * Intentar recuperar la reproducci√≥n
   */
  async attemptRecovery() {
    try {
      // PROTECCI√ìN CR√çTICA: No intentar recovery durante crossfade
      if (this.isCrossfading) {
        console.log('üîÑ Recovery cancelado - crossfade en progreso');
        return;
      }
      
      console.log('üîß Intentando recuperar reproducci√≥n...');
      const activePlayer = this.getActivePlayer();
      
      if (!activePlayer) {
        console.error('‚ùå No hay reproductor activo para recuperar');
        this.emit('onEnd', this.currentSong);
        return;
      }

      // Verificar si realmente est√° parado
      if (activePlayer.paused || activePlayer.ended) {
        console.log('üîÑ Reproductor pausado/terminado, reintentando...');
        
        // Si termin√≥, emitir evento onEnd
        if (activePlayer.ended) {
          console.log('üì¢ Emitiendo onEnd por recuperaci√≥n - canci√≥n terminada');
          this.emit('onEnd', this.currentSong);
          return;
        }
        
        // Si solo est√° pausado, intentar reproducir
        await activePlayer.play();
        console.log('‚úÖ Reproducci√≥n recuperada desde pausa');
        return;
      }

      // Caso cr√≠tico: Audio "colgado" - dice que reproduce pero no progresa
      console.log('üö® Audio colgado detectado - verificando si es falso positivo...');
      console.log('üìä Estado antes del reset:', {
        currentTime: activePlayer.currentTime,
        duration: activePlayer.duration,
        readyState: activePlayer.readyState,
        networkState: activePlayer.networkState,
        paused: activePlayer.paused,
        ended: activePlayer.ended,
        isCrossfading: this.isCrossfading // DEBUG: verificar estado crossfade
      });

      // üîß MEJORADO: Verificar si realmente est√° colgado o es un falso positivo
      // Despu√©s de crossfades, puede haber un breve per√≠odo donde el progreso parece detenido
      if (activePlayer.readyState >= 3 && activePlayer.networkState === 1 && !activePlayer.paused) {
        // üîß NUEVO: Verificar si la canci√≥n realmente termin√≥
        if (activePlayer.currentTime >= activePlayer.duration - 0.5) {
          console.log('üîö Canci√≥n terminada detectada por watchdog - emitiendo onEnd');
          this.emit('onEnd', this.currentSong);
          return;
        }
        
        // El audio parece estar bien, puede ser un falso positivo despu√©s de crossfade
        console.log('üîÑ Posible falso positivo despu√©s de crossfade - reseteando watchdog');
        this.lastProgressTime = Date.now();
        return;
      }

      // En lugar de intentar reparar, saltar directamente a la siguiente canci√≥n
      // Esto es m√°s confiable que intentar "reparar" un audio colgado
      console.log('‚è≠Ô∏è Forzando avance por audio colgado');
      
      // Reset completo del estado de reproducci√≥n
      this.isPlaying = false;
      this.isPaused = false;
      this.isCrossfading = false;
      
      // Limpiar el reproductor problem√°tico
      if (activePlayer) {
        try {
          activePlayer.pause();
          activePlayer.currentTime = 0;
        } catch (e) {
          console.warn('‚ö†Ô∏è Error pausando reproductor colgado:', e);
        }
      }
      
      console.log('üì¢ Emitiendo onEnd para forzar avance a siguiente canci√≥n');
      this.emit('onEnd', this.currentSong);

    } catch (error) {
      console.error('‚ùå Error en recuperaci√≥n:', error);
      // Fallback: siempre saltar a siguiente canci√≥n si hay problemas
      console.log('üîÑ Fallback final: saltando a siguiente canci√≥n');
      this.isPlaying = false;
      this.emit('onEnd', this.currentSong);
    }
  }

  /**
   * Detener watchdog
   */
  stopWatchdog() {
    if (this.watchdogInterval) {
      clearInterval(this.watchdogInterval);
      this.watchdogInterval = null;
    }
  }

  /**
   * üîß NUEVO: Activar/desactivar debug del watchdog
   */
  setWatchdogDebugMode(enabled) {
    this.watchdogDebugMode = enabled;
    console.log(`üîß Watchdog debug mode: ${enabled ? 'ACTIVADO' : 'DESACTIVADO'}`);
  }

  /**
   * Suscribirse a eventos
   */
  on(event, callback) {
    if (this.eventListeners[event]) {
      this.eventListeners[event].push(callback);
    }
  }

  /**
   * Desuscribirse de eventos
   */
  off(event, callback) {
    if (this.eventListeners[event]) {
      this.eventListeners[event] = this.eventListeners[event].filter(cb => cb !== callback);
    }
  }

  /**
   * Emitir evento
   */
  emit(event, data) {
    if (this.eventListeners[event]) {
      this.eventListeners[event].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error en callback ${event}:`, error);
        }
      });
    }
  }

  /**
   * Limpiar un reproductor espec√≠fico
   */
  cleanupPlayer(player) {
    if (!player) return;
    
    try {
      // Remover eventos
      if (player._eventHandlers) {
        Object.entries(player._eventHandlers).forEach(([event, handler]) => {
          player.removeEventListener(event, handler);
        });
        delete player._eventHandlers;
      }
      
      // Pausar y limpiar
      player.pause();
      player.src = '';
      player.load();
    } catch (error) {
      console.warn('‚ö†Ô∏è Error limpiando reproductor:', error);
    }
  }

  /**
   * Destruir servicio y limpiar recursos
   */
  destroy() {
    console.log('üóëÔ∏è Destruyendo AudioPlayerService');
    
    // Detener watchdog
    this.stopWatchdog();
    
    this.cleanupPlayer(this.playerA);
    this.cleanupPlayer(this.playerB);
    
    this.playerA = null;
    this.playerB = null;
    this.currentSong = null;
    this.nextSong = null;
    this.eventListeners = {};
  }

  /**
   * Resetear posici√≥n de reproducci√≥n
   */
  resetPlayback() {
    const activePlayer = this.getActivePlayer();
    if (activePlayer) {
      activePlayer.currentTime = 0;
      this.emit('onProgress', {
        currentTime: 0,
        duration: activePlayer.duration || 0,
        progress: 0
      });
    }
  }

  /**
   * Establecer canal actual para verificaciones de consistencia
   */
  setCurrentChannel(channelId) {
    console.log('üéõÔ∏è AudioPlayer - Canal establecido:', channelId);
    this.currentChannelId = channelId;
  }

  /**
   * EMERGENCIA: Limpiar canci√≥n precargada si es de canal incorrecto
   */
  forceCleanIncorrectPreloadedSong() {
    if (this.nextSong && this.nextSong.canciones && this.currentChannelId) {
      const nextSongChannelId = this.nextSong.canciones.canal_id;
      const nextSongTitle = this.nextSong.canciones.titulo;
      
      if (nextSongChannelId !== this.currentChannelId) {
        console.error('üö® EMERGENCIA - Limpiando canci√≥n precargada incorrecta:', {
          nextSongTitle,
          nextSongChannelId,
          currentChannelId: this.currentChannelId
        });
        
        // Limpiar inmediatamente
        this.nextSong = null;
        this.nextSongLoaded = false;
        
        // Limpiar reproductor inactivo
        const inactivePlayer = this.getInactivePlayer();
        if (inactivePlayer) {
          this.cleanupPlayer(inactivePlayer);
        }
        
        console.log('‚úÖ Canci√≥n incorrecta eliminada del sistema');
        return true;
      }
    }
    return false;
  }

  /**
   * Obtener canal actual
   */
  getCurrentChannelId() {
    return this.currentChannelId;
  }

  /**
   * Resetear completamente el estado del reproductor
   */
  reset() {
    try {
      console.log('üîÑ Reseteando AudioPlayerService...');
      
      // Mostrar estado antes del reset para debugging
      console.log('üìä Estado antes del reset:', {
        currentSong: this.currentSong?.canciones?.titulo || this.currentSong?.titulo || 'Ninguna',
        nextSong: this.nextSong?.canciones?.titulo || this.nextSong?.titulo || 'Ninguna',
        nextSongLoaded: this.nextSongLoaded,
        isCrossfading: this.isCrossfading,
        currentPlayer: this.currentPlayer,
        playerA: !!this.playerA,
        playerB: !!this.playerB
      });
      
      // Detener watchdog
      this.stopWatchdog();
      
      // Limpiar reproductores con informaci√≥n detallada
      if (this.playerA) {
        console.log('üßπ Limpiando reproductor A');
        this.cleanupPlayer(this.playerA);
      }
      if (this.playerB) {
        console.log('üßπ Limpiando reproductor B');
        this.cleanupPlayer(this.playerB);
      }
      
      // Resetear propiedades
      this.playerA = null;
      if (CROSSFADE_ENABLED) {
        this.playerB = null;
      }
      this.currentPlayer = 'A';
      this.isPlaying = false;
      this.isPaused = false;
      this.currentSong = null;
      this.nextSong = null; // CR√çTICO: Limpiar canci√≥n precargada
      this.currentChannelId = null; // CR√çTICO: Limpiar canal actual
      this.isCrossfading = false;
      this.isLoading = false;
      this.nextSongLoaded = false; // CR√çTICO: Resetear estado de precarga
      
      // Resetear timers
      this.lastEndEvent = 0;
      this.lastProgressTime = 0;
      
      console.log('‚úÖ AudioPlayerService reseteado completamente');
      console.log('üìä Estado despu√©s del reset:', {
        currentSong: this.currentSong,
        nextSong: this.nextSong,
        nextSongLoaded: this.nextSongLoaded,
        currentPlayer: this.currentPlayer,
        currentChannelId: this.currentChannelId,
        playerA: this.playerA,
        playerB: this.playerB
      });
      
      // Reiniciar watchdog para el pr√≥ximo uso
      this.startWatchdog();
      
    } catch (error) {
      console.error('‚ùå Error reseteando AudioPlayerService:', error);
    }
  }

  /**
   * Reproduce un contenido espec√≠fico con fade out/in del AutoDJ
   * @param {string} contentUrl - URL del contenido a reproducir
   * @param {number} duration - Duraci√≥n del contenido en segundos (opcional)
   * @returns {Promise<boolean>} - true si se reprodujo correctamente
   */
  async playContentWithFade(contentUrl, duration = null) {
    try {
      console.log('üéµ Iniciando reproducci√≥n de contenido con fade:', contentUrl);
      
      if (!contentUrl) {
        throw new Error('URL de contenido requerida');
      }

      // 0. Detener cualquier contenido que est√© reproduci√©ndose
      if (this.activeContentPlayer) {
        console.log('üõë Deteniendo contenido anterior...');
        this.activeContentPlayer.pause();
        this.activeContentPlayer.src = '';
        this.activeContentPlayer = null;
      }

      // 1. Fade out del audio actual
      const originalVolume = this.getActivePlayer()?.volume || 0.8;
      await this.fadeOutCurrentAudio();

      // 2. Crear nuevo reproductor temporal para el contenido
      const contentPlayer = new Audio();
      contentPlayer.preload = 'auto';
      contentPlayer.volume = this.contentVolume * this.masterVolume;
      
      // Guardar referencia al reproductor activo
      this.activeContentPlayer = contentPlayer;
      
      console.log('üîä Volumen del contenido configurado:', {
        contentVolume: this.contentVolume,
        masterVolume: this.masterVolume,
        finalVolume: this.contentVolume * this.masterVolume,
        volumenReal: contentPlayer.volume
      });

      // 3. Configurar eventos del contenido
      return new Promise((resolve) => {
        const handleContentEnd = async () => {
          console.log('‚úÖ Contenido finalizado, restaurando reproducci√≥n normal');
          
          // Limpiar eventos
          contentPlayer.removeEventListener('ended', handleContentEnd);
          contentPlayer.removeEventListener('error', handleContentError);
          
          // Limpiar referencia al reproductor activo
          this.activeContentPlayer = null;
          
          // Fade in del audio original
          await this.fadeInCurrentAudio(originalVolume);
          
          
          resolve(true);
        };

        const handleContentError = (error) => {
          console.error('‚ùå Error reproduciendo contenido:', error);
          console.error('‚ùå URL del contenido:', contentUrl);
          console.error('‚ùå Detalles del error:', {
            type: error.type,
            message: error.message,
            target: error.target
          });
          
          contentPlayer.removeEventListener('ended', handleContentEnd);
          contentPlayer.removeEventListener('error', handleContentError);
          
          // Limpiar referencia al reproductor activo
          this.activeContentPlayer = null;
          
          // Restaurar audio original en caso de error
          this.fadeInCurrentAudio(originalVolume);
          resolve(false);
        };

        contentPlayer.addEventListener('ended', handleContentEnd);
        contentPlayer.addEventListener('error', handleContentError);

        // 4. Cargar y reproducir contenido
        console.log('üéµ Configurando reproductor de contenido...');
        console.log('üéµ URL:', contentUrl);
        console.log('üéµ Vol√∫menes actuales:', {
          contentVolume: this.contentVolume,
          masterVolume: this.masterVolume,
          finalVolume: this.contentVolume * this.masterVolume
        });
        
        contentPlayer.src = contentUrl;
        
        // Agregar evento de carga para debugging
        contentPlayer.addEventListener('loadstart', () => {
          console.log('üéµ Iniciando carga del contenido...');
        });
        
        contentPlayer.addEventListener('canplay', () => {
          console.log('üéµ Contenido listo para reproducir');
          // Forzar aplicaci√≥n del volumen justo antes de reproducir
          contentPlayer.volume = this.contentVolume * this.masterVolume;
          console.log('üîä Volumen final aplicado al reproductor:', contentPlayer.volume);
        });
        
        contentPlayer.addEventListener('volumechange', () => {
          console.log('üîä Cambio de volumen detectado:', contentPlayer.volume);
        });
        
        contentPlayer.play().then(() => {
          console.log('üéµ Reproducci√≥n de contenido iniciada exitosamente');
          console.log('üîä Volumen durante reproducci√≥n:', contentPlayer.volume);
        }).catch(handleContentError);

        console.log('üéµ Contenido iniciado, duraci√≥n estimada:', duration ? `${duration}s` : 'desconocida');
      });

    } catch (error) {
      console.error('‚ùå Error en playContentWithFade:', error);
      return false;
    }
  }

  /**
   * Hace fade out del audio actual
   */
  async fadeOutCurrentAudio() {
    const currentPlayer = this.getActivePlayer();
    if (!currentPlayer) return;

    const originalVolume = currentPlayer.volume;
    const fadeSteps = 20;
    const stepDuration = 100; // ms
    const volumeStep = originalVolume / fadeSteps;

    console.log('üîΩ Iniciando fade out del audio actual');

    for (let i = 0; i < fadeSteps; i++) {
      currentPlayer.volume = Math.max(0, originalVolume - (volumeStep * (i + 1)));
      await new Promise(resolve => setTimeout(resolve, stepDuration));
    }

    currentPlayer.volume = 0;
    
    // üîß CR√çTICO: Pausar el audio despu√©s del fade out para evitar solapamiento
    currentPlayer.pause();
    this.isPlaying = false;
    this.isPaused = true;
    
    console.log('‚úÖ Fade out completado - audio pausado');
  }

  /**
   * Hace fade in del audio actual
   */
  async fadeInCurrentAudio(targetVolume = 0.8) {
    const currentPlayer = this.getActivePlayer();
    if (!currentPlayer) return;

    // üîß CR√çTICO: Reanudar la reproducci√≥n antes del fade in
    if (currentPlayer.paused) {
      try {
        await currentPlayer.play();
        this.isPlaying = true;
        this.isPaused = false;
        console.log('‚ñ∂Ô∏è Audio reanudado para fade in');
      } catch (error) {
        console.warn('‚ö†Ô∏è No se pudo reanudar el audio:', error);
        // Continuar con el fade in aunque no se pueda reanudar
      }
    }

    const fadeSteps = 20;
    const stepDuration = 100; // ms
    const volumeStep = targetVolume / fadeSteps;

    console.log('üîº Iniciando fade in del audio actual');

    for (let i = 0; i < fadeSteps; i++) {
      currentPlayer.volume = Math.min(targetVolume, volumeStep * (i + 1));
      await new Promise(resolve => setTimeout(resolve, stepDuration));
    }

    currentPlayer.volume = targetVolume;
    console.log('‚úÖ Fade in completado');
  }

  /**
   * Establecer volumen de m√∫sica (AutoDJ)
   */
  setMusicVolume(volume) {
    this.musicVolume = Math.max(0, Math.min(1, volume));
    console.log('üéµ Volumen m√∫sica actualizado:', this.musicVolume);
    
    // Aplicar al reproductor activo si existe
    const activePlayer = this.getActivePlayer();
    if (activePlayer) {
      activePlayer.volume = this.musicVolume * this.masterVolume;
    }
  }

  /**
   * Establecer volumen de contenidos
   */
  setContentVolume(volume) {
    const oldVolume = this.contentVolume;
    this.contentVolume = Math.max(0, Math.min(1, volume));
    
    // Si hay un contenido reproduci√©ndose, actualizar su volumen inmediatamente
    if (this.activeContentPlayer) {
      this.activeContentPlayer.volume = this.contentVolume * this.masterVolume;
      console.log('üîä Volumen aplicado al contenido activo:', this.activeContentPlayer.volume);
    }
    
    console.log('üé§ Volumen contenido actualizado:', {
      anterior: oldVolume,
      nuevo: this.contentVolume,
      entrada: volume,
      porcentaje: Math.round(this.contentVolume * 100) + '%',
      aplicadoAReproductorActivo: !!this.activeContentPlayer
    });
  }

  /**
   * Obtener volumen actual de m√∫sica
   */
  getMusicVolume() {
    return this.musicVolume;
  }

  /**
   * Obtener volumen actual de contenidos
   */
  getContentVolume() {
    return this.contentVolume;
  }



}

// Exportar singleton PEREZOSO (lazy) para evitar efectos en login
let _audioPlayerInstance = null;
const getInstance = () => {
  if (!_audioPlayerInstance) {
    _audioPlayerInstance = new AudioPlayerService();
  }
  return _audioPlayerInstance;
};

// Proxy que crea la instancia solo al acceder a un m√©todo/propiedad
const lazyAudioPlayer = new Proxy({}, {
  get(_target, prop) {
    const inst = getInstance();
    
    // Mostrar log de inicializaci√≥n solo cuando se accede por primera vez
    if (!inst._initialized) {
      console.log(`üéµ AudioPlayerService inicializado - Crossfade: ${CROSSFADE_ENABLED ? 'ACTIVADO' : 'DESACTIVADO'}, Interrupciones: ${INTERRUPTION_CROSSFADE_ENABLED ? 'ACTIVADO' : 'DESACTIVADO'}`);
      inst.startWatchdog();
      inst._initialized = true;
    }
    
    const value = inst[prop];
    if (typeof value === 'function') return value.bind(inst);
    return value;
  }
});

// Hacer accesible globalmente para debug en desarrollo, tambi√©n lazy
if (typeof window !== 'undefined') {
  Object.defineProperty(window, 'audioPlayerDebug', {
    get() { return getInstance(); }
  });
  
  window.forceWatchdogRecovery = () => {
    console.log('üîß Forzando recuperaci√≥n del watchdog...');
    getInstance().attemptRecovery();
  };
  
  window.simulateAudioHang = () => {
    console.log('üé≠ Simulando audio colgado...');
    getInstance().lastProgressTime = Date.now() - 10000; // 10 segundos atr√°s
  };
}

export default lazyAudioPlayer; 